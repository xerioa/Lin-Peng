using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using Emgu.CV.XImgproc;
using Emgu.CV; //opencv 主要函式
using Emgu.CV.CvEnum; //CV列舉項
using Emgu.CV.Cvb; //CVblob 功能
using Emgu.CV.Structure; //色彩形態定義
using Emgu.CV.UI; //imgbox顯示功能
using Emgu.CV.Util; //特殊形別定義 CV使用
using Emgu.Util;
using System.Diagnostics;

namespace BloodDetectApplication
{
    public partial class Form1 : Form
    {
        Boolean Modify_lock = false;
        Boolean Modify_lock1 = false;
        Boolean Modify_lock_add = false;
        Boolean Modify_lock_add1 = false;
        Boolean PanelScroll = true;
        Boolean PanelScroll1 = false;
        int Select_index = 0;
        float k = 3 / 2;
        int LockWhichPic = 3;
        String Path_Pic;
        int Ori_x = 520;
        int Ori_y = 520;
        Mat m;
        Point Rec;
        Point LightPoint;
        KeyEventArgs KEYYYY = new KeyEventArgs(Keys.A);
        Image<Bgr, byte> Save_subPic;
        Image<Bgr, byte> Recover_image;
        Image<Bgr, byte> Recover_image2;
        Image<Bgr, byte> Recover_image3;
        Image<Gray, byte> Save_subPic_gray;
        Image<Gray, byte> Save_subPic_gray_ori;
        Image<Bgr, byte> GreenGray;
        Image<Gray, byte> Save_circlefilter_gray;
        Image<Gray, byte> Area_filter_gray;
        Image<Bgr, byte> LockImage;
        Image<Gray, byte> LockImage_gray;
        Image<Bgr, byte> Layer;
        Image<Bgr, byte> Layer2;
        Image<Bgr, byte> imgx;
        Image<Bgr, byte> oriA;
        Image<Bgr, byte> SplitPic;
        Image<Bgr, byte> ori;
        Image<Bgr, byte> oriForever;
        Image<Bgr, byte> dst;
        Image<Bgr, byte> img_region;
        Image<Hsv, byte> Hsv;
        Image<Bgr, byte> Save_Contour_image;
        Image<Bgr, byte> RGB = new Image<Bgr, byte>(1040, 1040);
        Image<Gray, byte> gray;
        Image<Gray, byte> gray1;
        Image<Gray, byte> gray2;
        Image<Gray, byte> thresholdImage;
        Image<Gray, byte> Pattern_R;
        Image<Gray, byte> Pattern_G;
        Image<Gray, byte> Pattern_B;
        Image<Gray, byte> Pattern;
        Image<Gray, byte> CannyMeddle;
        public Form1()
        {
            InitializeComponent();
            ThreadValue.Text = thresholdvalue.Value.ToString();
            initialDatagrid();
        }
        private void initialDatagrid()
        {
            dataGridView1.RowCount = 1;
            dataGridView1.ColumnCount = 1;
            dataGridView1.Columns[0].Name = "編號";
            dataGridView1.Columns[0].SortMode = DataGridViewColumnSortMode.NotSortable;
            dataGridView1.Columns[0].HeaderCell.Style.Alignment = DataGridViewContentAlignment.MiddleCenter;
            dataGridView1.Columns[0].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleCenter;
            // dataGridView1.Columns.Add("Column1", "編號");
            dataGridView1.Columns.Add("Column2", "面積(pixels)");
            dataGridView1.Columns[1].SortMode = DataGridViewColumnSortMode.NotSortable;
            dataGridView1.Columns[1].HeaderCell.Style.Alignment = DataGridViewContentAlignment.MiddleRight;
            dataGridView1.Columns[1].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleRight;
            dataGridView1.Columns.Add("Column3", "擬合橢圓長短軸比值(Aspect ratio)");
            dataGridView1.Columns[2].SortMode = DataGridViewColumnSortMode.NotSortable;
            dataGridView1.Columns[2].HeaderCell.Style.Alignment = DataGridViewContentAlignment.MiddleRight;
            dataGridView1.Columns[2].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleRight;
            dataGridView1.Columns.Add("Column4", "面積與擬合橢圓面積比值(ratio of Area in Fitting Ellipse)");
            dataGridView1.Columns[3].SortMode = DataGridViewColumnSortMode.NotSortable;
            dataGridView1.Columns[3].HeaderCell.Style.Alignment = DataGridViewContentAlignment.MiddleRight;
            dataGridView1.Columns[3].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleRight;
            //taGridView1.Columns.Add("Column5", "明亮度(Mean)");
            //taGridView1.Columns[4].SortMode = DataGridViewColumnSortMode.NotSortable;
            //taGridView1.Columns[4].HeaderCell.Style.Alignment = DataGridViewContentAlignment.MiddleRight;
            //taGridView1.Columns[4].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleRight;
            dataGridView1.AutoResizeColumns();
            //this.dataGridView1.Rows.Add(n + 1, area);


        }

        private void button1_Click(object sender, EventArgs e)
        {
            OpenFileDialog Openfile = new OpenFileDialog();
            Openfile.Filter = "TIFF 檔(*.tiff) |*.tiff|" + "BMP 檔(*.bmp) |*.bmp|" + "PNG 檔(*.png) |*.png|" + "JPEG 檔(*.jpeg) |*.jpeg|" + "JPG 檔(*.jpg) |*.jpg";
            Openfile.Title = "選擇一個圖片檔案";
            if (Openfile.ShowDialog() == DialogResult.OK)
            {
                imgx = new Image<Bgr, byte>(Openfile.FileName);
                MCvScalar MCV = CvInvoke.Mean(imgx);
                Mean.Text = Math.Round(MCV.V0).ToString();
                if (Math.Round(MCV.V0) > 30)
                {
                    imgx._EqualizeHist();
                    imgx._GammaCorrect((double)Gamma_value.Value);
                }
                ori = new Image<Bgr, byte>(Openfile.FileName);

                oriForever = new Image<Bgr, byte>(Openfile.FileName);
                oriA = new Image<Bgr, byte>(Openfile.FileName);
                Hsv = new Image<Hsv, byte>(Openfile.FileName);
                Path_Pic = Openfile.FileName;
                gray = new Image<Gray, byte>(imgx.ToBitmap());
                gray1 = new Image<Gray, byte>(imgx.ToBitmap());
                gray2 = new Image<Gray, byte>(imgx.ToBitmap());
                thresholdImage = new Image<Gray, byte>(imgx.ToBitmap());

                Pattern_B = new Image<Gray, byte>(imgx[0].ToBitmap());
                Pattern_G = new Image<Gray, byte>(imgx[1].ToBitmap());
                Pattern_R = new Image<Gray, byte>(imgx[2].ToBitmap());

                imageBox1.Image = imgx;

            }
        }

        private void button2_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> CIR = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                CIR._EqualizeHist();
                CIR._GammaCorrect((double)Gamma_value.Value);
                MCvScalar MCV = CvInvoke.Mean(CIR);
                Mean.Text = Math.Round(MCV.V0).ToString();
                imageBox1.Image = CIR;
            }
        }

        private void button3_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                gray = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> CIR3 = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                MCvScalar MCV = CvInvoke.Mean(CIR3);
                CvInvoke.Threshold(CIR3, CIR3, OtsuImg(CIR3, (int)MCV.V0 + 15, 35), 255, ThresholdType.Binary);
                imageBox1.Image = gray;
            }
        }

        private void button4_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                gray = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> CIR3 = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                CvInvoke.Threshold(CIR3, gray, 0, 255, ThresholdType.Otsu);
                CvInvoke.Threshold(gray, gray, 0, 255, ThresholdType.BinaryInv);
                imageBox1.Image = gray;
            }
        }

        private void button5_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> CIR = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> imgA = new Image<Bgr, byte>(CIR.ToBitmap());
                Image<Gray, byte> imgB = new Image<Gray, byte>(CIR.ToBitmap());
                Image<Bgr, byte> img_Display = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
                Image<Bgr, byte> img_Displayggg = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
                Image<Gray, byte> CIR2 = new Image<Gray, byte>(1040, 1040);

                CvInvoke.Circle(CIR2, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255), -1);

                VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存


                for (int i = 0; i < imgB.Width; i++)
                {
                    for (int j = 0; j < imgB.Height; j++)
                    {
                        if (Math.Sqrt(Math.Pow(i - 520, 2) + Math.Pow(j - 520, 2)) - 520 > 0)
                        {
                            imgB.Data[j, i, 0] = 0;
                        }
                    }
                }
                VectorOfRect hierarchy = new VectorOfRect();

                if (Allow_Circle.Checked)
                    CvInvoke.FindContours(imgB.Add(CIR2), contours_White, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 
                else
                    CvInvoke.FindContours(imgB, contours_White, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 


                for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {

                    //imgB.SetZero();
                    // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                    double A = CvInvoke.ContourArea(contours_White[i]);
                    // Debug.Print(A.ToString());


                    MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                    int[] Cx = new int[contours_White.Size];  //x座標
                    int[] Cy = new int[contours_White.Size];  //y座標                
                    mom[i] = CvInvoke.Moments(contours_White[i]);
                    Cx[i] = (int)mom[i].GravityCenter.X;
                    Cy[i] = (int)mom[i].GravityCenter.Y;
                    if (A > 25)
                    {
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                        Point rcenter = new Point(Cx[i], Cy[i]);

                        double W = (int)rotatedRect.Size.Width;
                        double H = (int)rotatedRect.Size.Height;
                        if (A > (double)Area_Flower.Value && A < 1000000)
                        {
                            if (H / W > (double)W_Hrate.Value)
                            {
                                //CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(255, 255, 255), 3);
                                //找輪廓語法 
                                CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                if (hierarchy[i].Height != -1)
                                {
                                    CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(0, 0, 0), -1);
                                }
                                //seed = new Point(Cx[i], Cy[i]);
                            }
                            else
                            {
                                if (A > 20000)
                                {
                                    CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                    if (hierarchy[i].Height != -1)
                                    {
                                        CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(0, 0, 0), -1);
                                    }
                                }
                            }


                        }
                        else
                        {
                            {

                                if (H / W > (double)W_Hrate.Value)
                                {
                                    CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                    if (hierarchy[i].Height != -1)
                                    {
                                        CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(0, 0, 0), -1);
                                    }
                                }


                                if (A > 1000000)
                                {
                                    img_Display = imgA;
                                }
                            }

                        }


                        //CvInvoke.PutText(img_Display, Color_R[i].ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);

                    }
                    //for (int i = 0; i < contours_Useless.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                    //{

                    //        CvInvoke.DrawContours(img_Display2, contours_Useless, i, new MCvScalar(255, 255, 255), -1);
                    //    //CvInvoke.PutText(img_Display, Color_R[i].ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);
                    //}
                    //img_Display._And(oriForever);
                    imageBox1.Image = img_Displayggg;
                    //CvInvoke.FloodFill(img_Display, img_Displayggg, seed, new MCvScalar(255,255,255), out RR, new MCvScalar(0, 0,0),new MCvScalar(255, 255, 255));


                }

            }
        }
        private void FindCott(Image<Gray, byte> img, ImageBox PIC, double AREA, double Rate)
        {
            Image<Bgr, byte> imgA = new Image<Bgr, byte>(img.ToBitmap());
            Image<Gray, byte> imgB = new Image<Gray, byte>(img.ToBitmap());
            Image<Bgr, byte> img_Display = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
            Image<Bgr, byte> img_Displayggg = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
            Image<Gray, byte> CIR2 = new Image<Gray, byte>(1040, 1040);
            Point seed = new Point(0, 0);
            Rectangle RR = new Rectangle(0, 0, 0, 0);
            CvInvoke.Circle(CIR2, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255), -1);

            VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存


            for (int i = 0; i < imgB.Width; i++)
            {
                for (int j = 0; j < imgB.Height; j++)
                {
                    if (Math.Sqrt(Math.Pow(i - 520, 2) + Math.Pow(j - 520, 2)) - 520 > 0)
                    {
                        imgB.Data[j, i, 0] = 0;
                    }
                }
            }
            Mat hierarchy = new Mat();

            if (Allow_Circle.Checked)

                CvInvoke.FindContours(imgB.Add(CIR2), contours_White, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 
            else
                CvInvoke.FindContours(imgB, contours_White, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 



            String[] Color_R = new String[contours_White.Size];
            for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
            {

                //imgB.SetZero();
                // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                double A = CvInvoke.ContourArea(contours_White[i]);
                // Debug.Print(A.ToString());


                MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                int[] Cx = new int[contours_White.Size];  //x座標
                int[] Cy = new int[contours_White.Size];  //y座標                
                mom[i] = CvInvoke.Moments(contours_White[i]);
                Cx[i] = (int)mom[i].GravityCenter.X;
                Cy[i] = (int)mom[i].GravityCenter.Y;
                if (A > 5)
                {
                    RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                    Point rcenter = new Point(Cx[i], Cy[i]);

                    double W = (int)rotatedRect.Size.Width;
                    double H = (int)rotatedRect.Size.Height;
                    if (A > AREA && A < 1000000)
                    {
                        if (H / W > Rate)
                        {
                            CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(255, 255, 255), 3);
                            CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(255, 255, 255), -1);
                            //seed = new Point(Cx[i], Cy[i]);
                        }
                        else
                        {
                            if (A > 20000)
                            {
                                CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(255, 255, 255), 3);
                                CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                //if (hierarchy[i][3] != -1)
                                //    CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(180, 215, 215), -1);
                                //seed = new Point(Cx[i], Cy[i]);
                            }
                        }


                    }
                    else
                    {
                        {

                            if (H / W > Rate)
                            {
                                CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(255, 255, 255), 3);
                                CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                //if (hierarchy[0][0][3][3] != -1)
                                //    CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(180, 215, 215), -1);
                                //seed = new Point(Cx[i], Cy[i]);
                            }


                            if (A > 1000000)
                            {
                                img_Display = imgA;
                            }
                        }

                    }


                    //CvInvoke.PutText(img_Display, Color_R[i].ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);

                }
                //for (int i = 0; i < contours_Useless.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                //{

                //        CvInvoke.DrawContours(img_Display2, contours_Useless, i, new MCvScalar(255, 255, 255), -1);
                //    //CvInvoke.PutText(img_Display, Color_R[i].ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);
                //}
                //img_Display._And(oriForever);
                PIC.Image = img_Display;
                //CvInvoke.FloodFill(img_Display, img_Displayggg, seed, new MCvScalar(255,255,255), out RR, new MCvScalar(0, 0,0),new MCvScalar(255, 255, 255));


            }

        }




        private void Form1_KeyDown(object sender, KeyEventArgs e)
        {

        }



        private void button10_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> CIR = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> CIR2 = new Image<Bgr, byte>(1040, 1040);

                Image<Bgr, byte> ori_area = new Image<Bgr, byte>(1040, 1040);

                Image<Bgr, byte> improve_area = new Image<Bgr, byte>(1040, 1040);
                VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存       
                CvInvoke.FindContours(CIR, contours_White, null, RetrType.External, ChainApproxMethod.ChainApproxNone);  //找輪廓語法 
                for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {

                    //imgB.SetZero();
                    // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                    double A = CvInvoke.ContourArea(contours_White[i]);
                    //Debug.Print(A.ToString());
                    if (A > 50)
                    {
                        MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                        int[] Cx = new int[contours_White.Size];  //x座標
                        int[] Cy = new int[contours_White.Size];  //y座標 
                        mom[i] = CvInvoke.Moments(contours_White[i]);
                        Cx[i] = (int)mom[i].GravityCenter.X;
                        Cy[i] = (int)mom[i].GravityCenter.Y;
                        try
                        {
                            RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                            Point rcenter = new Point(Cx[i], Cy[i]);
                            CvInvoke.DrawContours(CIR2, contours_White, i, new MCvScalar(255, 255, 255), -1);
                            CvInvoke.Ellipse(CIR2, rcenter, new Size((int)(rotatedRect.Size.Width / 2), (int)(rotatedRect.Size.Height / 2)), rotatedRect.Angle, 0, 360, new MCvScalar(0, 0, 255), 2);
                            CvInvoke.DrawContours(ori_area, contours_White, i, new MCvScalar(255, 255, 255), -1);
                            CvInvoke.DrawContours(improve_area, contours_White, i, new MCvScalar(0, 0, 255), -1);
                            CvInvoke.DrawContours(improve_area, contours_White, i, new MCvScalar(255, 255, 255), -1);
                            double[] Max_X = new double[contours_White.Size];
                            double[] Max_Y = new double[contours_White.Size];
                            double[] Min_X = new double[contours_White.Size];
                            double[] Min_Y = new double[contours_White.Size];

                            for (int j = 0; j < contours_White[i].Size; j++)
                            {
                                if (j > 1)
                                {
                                    if (Math.Pow((double)(contours_White[i][j].X - contours_White[i][0].X), 2) + Math.Pow((double)(contours_White[i][j].Y - contours_White[i][0].Y), 2) > Math.Pow((double)(Max_X[i] - contours_White[i][0].X), 2) + Math.Pow((double)(Max_Y[i] - contours_White[i][0].Y), 2))
                                    {
                                        Max_X[i] = contours_White[i][j].X;
                                        Max_Y[i] = contours_White[i][j].Y;
                                    }
                                    if (Math.Pow((double)(contours_White[i][j].X - 520), 2) + Math.Pow((double)(contours_White[i][j].Y - 520), 2) > Math.Pow((double)(Max_X[i] - 520), 2) + Math.Pow((double)(Max_Y[i] - 520), 2))
                                    {
                                        Max_X[i] = contours_White[i][j].X;
                                        Max_Y[i] = contours_White[i][j].Y;
                                    }
                                    if (Math.Pow((double)(contours_White[i][j].X - 520), 2) + Math.Pow((double)(contours_White[i][j].Y - 520), 2) < Math.Pow((double)(Min_X[i] - 520), 2) + Math.Pow((double)(Min_Y[i] - 520), 2))
                                    {
                                        Min_X[i] = contours_White[i][j].X;
                                        Min_Y[i] = contours_White[i][j].Y;
                                    }

                                }
                                else
                                {
                                    Max_X[i] = contours_White[i][j].X;
                                    Max_Y[i] = contours_White[i][j].Y;
                                    Min_X[i] = contours_White[i][j].X;
                                    Min_Y[i] = contours_White[i][j].Y;
                                }

                            }
                            improve_area.Data[contours_White[i][0].Y, contours_White[i][0].X, 0] = 0;
                            improve_area.Data[contours_White[i][0].Y, contours_White[i][0].X, 1] = 0;
                            improve_area.Data[contours_White[i][0].Y, contours_White[i][0].X, 2] = 255;
                            improve_area.Data[(int)Min_Y[i], (int)Min_X[i], 0] = 255;
                            improve_area.Data[(int)Min_Y[i], (int)Min_X[i], 1] = 0;
                            improve_area.Data[(int)Min_Y[i], (int)Min_X[i], 2] = 255;
                            improve_area.Data[(int)Max_Y[i], (int)Max_X[i], 0] = 0;
                            improve_area.Data[(int)Max_Y[i], (int)Max_X[i], 1] = 255;
                            improve_area.Data[(int)Max_Y[i], (int)Max_X[i], 2] = 255;
                            double C = (int)rotatedRect.Size.Width;
                            double B = (int)rotatedRect.Size.Height;
                            if ((int)rotatedRect.Size.Width > 111)
                            {
                                if ((B / C) < 5)
                                {
                                    CvInvoke.Line(improve_area, new Point((int)Min_X[i], (int)Min_Y[i]), new Point((int)Max_X[i], (int)Max_Y[i]), new MCvScalar(0, 0, 0), 110 / 2, LineType.EightConnected);
                                }
                                else
                                {
                                    CvInvoke.Line(improve_area, new Point((int)Min_X[i], (int)Min_Y[i]), new Point((int)Max_X[i], (int)Max_Y[i]), new MCvScalar(0, 0, 0), 110, LineType.EightConnected);
                                }
                            }
                            else
                            {
                                if ((B / C) < 5)
                                {
                                    CvInvoke.Line(improve_area, new Point((int)Min_X[i], (int)Min_Y[i]), new Point((int)Max_X[i], (int)Max_Y[i]), new MCvScalar(0, 0, 0), (int)rotatedRect.Size.Width / 4, LineType.EightConnected);
                                }
                                else
                                {
                                    CvInvoke.Line(improve_area, new Point((int)Min_X[i], (int)Min_Y[i]), new Point((int)Max_X[i], (int)Max_Y[i]), new MCvScalar(0, 0, 0), (int)rotatedRect.Size.Width, LineType.EightConnected);
                                }

                            }
                            //CvInvoke.PutText(improve_area, i.ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);

                        }
                        catch (Exception ex)
                        {
                            MessageBox.Show(ex.ToString());
                        }

                    }
                    else
                    {
                    }

                }
                Area_filter_gray = new Image<Gray, byte>(improve_area.Bitmap);
                imageBox1.Image = improve_area;



            }
        }

        private void button8_Click(object sender, EventArgs e)
        {
            if (Path_Pic == null)
            {
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Mat dst = new Mat();
                Mat scr = new Mat(Path_Pic);
                Image<Bgr, byte> ori = new Image<Bgr, byte>(Path_Pic);
                imgx = ori;
                imageBox1.Image = scr;
                thresholdImage = gray;
            }

        }

        private void button7_Click(object sender, EventArgs e)
        {
            imageBox1.Image = Recover_image;
        }

        private void button11_Click(object sender, EventArgs e)
        {

        }

        private void button12_Click(object sender, EventArgs e)
        {

        }

        private void button13_Click(object sender, EventArgs e)
        {

        }






        private void hScrollBar1_Scroll(object sender, ScrollEventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                try
                {
                    Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                    ThreadValue.Text = thresholdvalue.Value.ToString();
                    //Image<Gray, byte> CIR_ori = new Image<Gray, byte>(Save_subPic_gray_ori.Bitmap);
                    Image<Gray, byte> CIR = new Image<Gray, byte>(Save_subPic_gray.Bitmap);
                    Image<Gray, byte> CIR_max = new Image<Gray, byte>(Save_subPic_gray.Bitmap);
                    //if (Allow_connect.Checked)
                    //{
                    //    CIR = CIR.Or(CIR_ori);
                    //}
                    // CIR_max = CIR_max.Or(CIR_ori);
                    CvInvoke.Threshold(CIR, CIR_max, thresholdvalue_max.Value, 255, ThresholdType.Binary);
                    CvInvoke.Threshold(CIR, CIR, thresholdvalue.Value, 255, ThresholdType.Binary);
                    CIR = CIR.Xor(CIR_max);
                    Image<Bgr, byte> Display = new Image<Bgr, byte>(CIR.Bitmap);
                    Display._And(ori);
                    initialDatagrid();
                    Recover_image = new Image<Bgr, byte>(Display.Bitmap);
                    Image<Bgr, byte> imgxx = new Image<Bgr, byte>(ori.Bitmap);
                    Image<Bgr, byte> imgB = new Image<Bgr, byte>(Display.Bitmap);
                    Image<Bgr, byte> imgC = new Image<Bgr, byte>(ori.Width, ori.Height);
                    Image<Gray, byte> CIR5 = new Image<Gray, byte>(Display.Bitmap);

                    VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存     
                    int Count = 0;
                    CvInvoke.FindContours(CIR5, contours_White, null, RetrType.External, ChainApproxMethod.ChainApproxNone);  //找輪廓語法 
                    for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                    {
                        double AREA = CvInvoke.ContourArea(contours_White[i]);
                        MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                        int[] Cx = new int[contours_White.Size];  //x座標
                        int[] Cy = new int[contours_White.Size];  //y座標 
                        mom[i] = CvInvoke.Moments(contours_White[i]);
                        Cx[i] = (int)mom[i].GravityCenter.X;
                        Cy[i] = (int)mom[i].GravityCenter.Y;
                        if (AREA > (double)Threshold_Area.Value)
                        {

                            RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                            Point rcenter = new Point(Cx[i], Cy[i]);
                            double A = (int)rotatedRect.Size.Width;
                            double B = (int)rotatedRect.Size.Height;
                            if (Math.Round(B / A, 1) < (double)W_HRate_defect.Value)
                            {
                                Count++;
                                CvInvoke.DrawContours(imgB, contours_White, i, new MCvScalar(0, 255, 255), 1);
                                CvInvoke.DrawContours(imgC, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                if (number_visible.Checked)
                                    CvInvoke.PutText(imgB, Count.ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 2);
                                //CvInvoke.Circle(imgB, new System.Drawing.Point(Cx[i], Cy[i]), 5, new MCvScalar(0, 0, 255), -1);
                                dataGridView1.Rows.Add(Count.ToString(), ((int)AREA).ToString(), Math.Round(B / A, 2).ToString(), Math.Round((int)AREA / (B * A * Math.PI) * 4, 2).ToString());
                                for (int x = 0; x < contours_White[i].Size; x = x + 30)
                                {
                                    if (circle_round.Checked)
                                        CvInvoke.Circle(imgB, new Point(contours_White[i][x].X, contours_White[i][x].Y), (int)RoundShape.Value, new MCvScalar(255, 255, 255), -1);
                                    if (rect_round.Checked)
                                        CvInvoke.Rectangle(imgB, new Rectangle(contours_White[i][x].X - (int)RoundShape.Value, contours_White[i][x].Y - (int)RoundShape.Value, 2 * (int)RoundShape.Value, 2 * (int)RoundShape.Value), new MCvScalar(255, 255, 255), -1);
                                    if (triangle_round.Checked)
                                    { }
                                    if (none_round.Checked)
                                    { }
                                    //CvInvoke.(imgB, new Point(contours_White[i][x].X, contours_White[i][x].Y), 10, new MCvScalar(255, 255, 255), -1);


                                    //CvInvoke.Line(imgB, new Point(contours_White[i][x].X, contours_White[i][x].Y), new Point(Cx[i], Cy[i]), new MCvScalar(255, 255, 255), 1);
                                    //imgB.Data[contours_White[i][x].Y, contours_White[i][x].X, 0] = 255;
                                    //imgB.Data[contours_White[i][x].Y, contours_White[i][x].X, 1] = 255;
                                    //imgB.Data[contours_White[i][x].Y, contours_White[i][x].X, 2] = 255;
                                }

                            }
                        }
                    }
                    Image<Gray, byte> imgB_gray = new Image<Gray, byte>(imgB.Bitmap);
                    Image<Bgr, byte> imgB_2 = new Image<Bgr, byte>(1040, 1040);
                    if (none_round.Checked)
                    {
                        imgB_gray = imgB_gray.Erode(4);
                        VectorOfVectorOfPoint contours_gray = new VectorOfVectorOfPoint();  //找到的輪廓儲存     
                        CvInvoke.FindContours(imgB_gray, contours_gray, null, RetrType.External, ChainApproxMethod.ChainApproxNone);
                        for (int i = 0; i < contours_gray.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                        {
                            CvInvoke.DrawContours(imgB_2, contours_gray, i, new MCvScalar(0, 255, 255), 1);
                        }
                        Save_Contour_image = imgC;
                        imgB_2 = imgB_2.Or(imgxx);
                        LockImage = new Image<Bgr, byte>(imgB_2.Bitmap);
                        imageBox1.Image = LockImage;
                    }
                    else
                    {
                        Save_Contour_image = imgC;
                        imgB = imgB.Or(imgxx);
                        LockImage = new Image<Bgr, byte>(imgB.Bitmap);
                        imageBox1.Image = LockImage;
                    }

                    //imageBox1.Image = imgC;
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.ToString());
                }


            }
        }

        private void dataGridView1_CellMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            Select_index = e.RowIndex;
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            initialDatagrid();
            Circle_location.Text = "(" + Ori_x.ToString() + "," + Ori_y.ToString() + ")";
            lbl_circlr_filter.Text = Circle_Filter.Value.ToString();
        }


        private void dataGridView1_CellValueChanged(object sender, DataGridViewCellEventArgs e)
        {

        }

        private void dataGridView1_RowsRemoved(object sender, DataGridViewRowsRemovedEventArgs e)
        {

        }

        private void dataGridView1_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (e.KeyChar == 46)
            {
                if (imageBox1.Image == null)
                {
                    MessageBox.Show("no image");
                }
                else
                {
                    initialDatagrid();
                    Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                    Image<Bgr, byte> imgxx = new Image<Bgr, byte>(ori.Bitmap);
                    Image<Bgr, byte> imgB = new Image<Bgr, byte>(Save_Contour_image.Bitmap);
                    Image<Bgr, byte> imgC = new Image<Bgr, byte>(ori.Width, ori.Height);
                    Image<Gray, byte> CIR5 = new Image<Gray, byte>(Save_Contour_image.Bitmap);
                    VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存     
                    int Count = 0;
                    CvInvoke.FindContours(CIR5, contours_White, null, RetrType.External, ChainApproxMethod.ChainApproxNone);  //找輪廓語法 
                    for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                    {
                        if (Select_index == i)
                        {
                            CvInvoke.DrawContours(imgB, contours_White, i, new MCvScalar(0, 0, 0), -1);
                        }
                        else
                        {
                            double AREA = CvInvoke.ContourArea(contours_White[i]);
                            MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                            int[] Cx = new int[contours_White.Size];  //x座標
                            int[] Cy = new int[contours_White.Size];  //y座標 
                            mom[i] = CvInvoke.Moments(contours_White[i]);
                            Cx[i] = (int)mom[i].GravityCenter.X;
                            Cy[i] = (int)mom[i].GravityCenter.Y;
                            if (AREA > (double)Threshold_Area.Value)
                            {
                                Count++;
                                RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                                Point rcenter = new Point(Cx[i], Cy[i]);
                                double A = (int)rotatedRect.Size.Width;
                                double B = (int)rotatedRect.Size.Height;
                                CvInvoke.DrawContours(imgB, contours_White, i, new MCvScalar(0, 0, 0), -1);
                                CvInvoke.DrawContours(imgB, contours_White, i, new MCvScalar(0, 255, 255), 1);
                                CvInvoke.DrawContours(imgC, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                if (number_visible.Checked)
                                    CvInvoke.PutText(imgB, Count.ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 2);
                                dataGridView1.Rows.Add(Count.ToString(), ((int)AREA).ToString(), Math.Round(B / A, 1).ToString(), Math.Round((int)AREA / (B * A * Math.PI) * 4, 2).ToString());
                            }
                        }
                    }
                    Save_Contour_image = imgC;
                    imageBox1.Image = imgB.Or(imgxx);
                }
            }
        }

        private void imageBox1_MouseDown(object sender, MouseEventArgs e)
        {
            if (Modify_lock)
                Modify_lock1 = true;
            else if (Modify_lock_add)
                Modify_lock_add1 = true;
            else if (PanelScroll)
            {
                if (PanelScroll1)
                {
                    //panel2.SetBounds(imageBox1.Location.X + (e.X), imageBox1.Location.Y + e.Y, 1040, 1040);

                }
                PanelScroll1 = true;
            }
        }



        private void imageBox1_OnZoomScaleChange(object sender, EventArgs e)
        {
            //imageBox1.SetZoomScale(1, new Point(520, 520));
        }

        private void imageBox1_RegionChanged(object sender, EventArgs e)
        {
            MessageBox.Show("d");
        }

        private void imageBox1_MouseUp(object sender, MouseEventArgs e)
        {
            imageBox1.SetZoomScale(1, new Point(520, 520));
            if (Modify_lock)
                Modify_lock1 = false;
            else if (Modify_lock_add)
                Modify_lock_add1 = false;
            else if (PanelScroll)
            {
                if (PanelScroll1)
                {
                    //panel2.SetBounds(imageBox1.Location.X + (e.X), imageBox1.Location.Y + e.Y, 1040, 1040);

                }
                PanelScroll1 = false;
            }

        }

        private void imageBox1_MouseMove(object sender, MouseEventArgs e)
        {
            try
            {

                if (Modify_lock1)
                {
                    for (int i = e.X - (int)Modify_Width.Value; i < e.X + (int)Modify_Width.Value; i++)
                    {
                        for (int j = e.Y - (int)Modify_Width.Value; j < e.Y + (int)Modify_Width.Value; j++)
                        {
                            for (int k = 0; k < 3; k++)
                            {
                                Save_Contour_image.Data[j, i, k] = 0;
                            }
                        }
                    }



                    initialDatagrid();
                    Image<Bgr, byte> imgxx = new Image<Bgr, byte>(ori.Bitmap);
                    Image<Bgr, byte> imgB = new Image<Bgr, byte>(ori.Width, ori.Height);
                    Image<Bgr, byte> imgC = new Image<Bgr, byte>(ori.Width, ori.Height);
                    Image<Gray, byte> CIR5 = new Image<Gray, byte>(Save_Contour_image.Bitmap);
                    VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存     
                    int Count = 0;
                    CvInvoke.FindContours(CIR5, contours_White, null, RetrType.External, ChainApproxMethod.ChainApproxNone);  //找輪廓語法 
                    for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                    {
                        double AREA = CvInvoke.ContourArea(contours_White[i]);
                        MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                        int[] Cx = new int[contours_White.Size];  //x座標
                        int[] Cy = new int[contours_White.Size];  //y座標 
                        mom[i] = CvInvoke.Moments(contours_White[i]);
                        Cx[i] = (int)mom[i].GravityCenter.X;
                        Cy[i] = (int)mom[i].GravityCenter.Y;
                        if (AREA > (double)Threshold_Area.Value)
                        {
                            Count++;
                            RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                            Point rcenter = new Point(Cx[i], Cy[i]);
                            double A = (int)rotatedRect.Size.Width;
                            double B = (int)rotatedRect.Size.Height;
                            CvInvoke.DrawContours(imgB, contours_White, i, new MCvScalar(0, 255, 255), 2);
                            CvInvoke.DrawContours(imgC, contours_White, i, new MCvScalar(255, 255, 255), -1);
                            if (number_visible.Checked)
                                CvInvoke.PutText(imgB, Count.ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 1);
                            dataGridView1.Rows.Add(Count.ToString(), ((int)AREA).ToString(), Math.Round(B / A, 1).ToString(), Math.Round((int)AREA / (B * A * Math.PI) * 4, 2).ToString());
                        }
                    }
                    Save_Contour_image = imgC;
                    imageBox1.Image = imgB.Or(imgxx);
                }
                else if (Modify_lock_add1)
                {
                    for (int i = e.X - (int)Modify_Width.Value; i < e.X + (int)Modify_Width.Value; i++)
                    {
                        for (int j = e.Y - (int)Modify_Width.Value; j < e.Y + (int)Modify_Width.Value; j++)
                        {
                            for (int k = 0; k < 3; k++)
                            {
                                Save_Contour_image.Data[j, i, k] = 255;
                            }
                        }
                    }
                    initialDatagrid();
                    Image<Bgr, byte> imgxx = new Image<Bgr, byte>(ori.Bitmap);
                    Image<Bgr, byte> imgB = new Image<Bgr, byte>(ori.Width, ori.Height);
                    Image<Bgr, byte> imgC = new Image<Bgr, byte>(ori.Width, ori.Height);
                    Image<Gray, byte> CIR5 = new Image<Gray, byte>(Save_Contour_image.Bitmap);
                    VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存     
                    int Count = 0;
                    CvInvoke.FindContours(CIR5, contours_White, null, RetrType.External, ChainApproxMethod.ChainApproxNone);  //找輪廓語法 
                    for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                    {
                        double AREA = CvInvoke.ContourArea(contours_White[i]);
                        MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                        int[] Cx = new int[contours_White.Size];  //x座標
                        int[] Cy = new int[contours_White.Size];  //y座標 
                        mom[i] = CvInvoke.Moments(contours_White[i]);
                        Cx[i] = (int)mom[i].GravityCenter.X;
                        Cy[i] = (int)mom[i].GravityCenter.Y;
                        if (AREA > (double)Threshold_Area.Value)
                        {
                            Count++;
                            RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                            Point rcenter = new Point(Cx[i], Cy[i]);
                            double A = (int)rotatedRect.Size.Width;
                            double B = (int)rotatedRect.Size.Height;
                            CvInvoke.DrawContours(imgB, contours_White, i, new MCvScalar(0, 255, 255), 1);
                            CvInvoke.DrawContours(imgC, contours_White, i, new MCvScalar(255, 255, 255), -1);
                            if (number_visible.Checked)
                                CvInvoke.PutText(imgB, Count.ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 2);
                            dataGridView1.Rows.Add(Count.ToString(), ((int)AREA).ToString(), Math.Round(B / A, 1).ToString(), Math.Round((int)AREA / (B * A * Math.PI) * 4, 2).ToString());
                        }
                    }
                    Save_Contour_image = imgC;
                    imageBox1.Image = imgB.Or(imgxx);
                }

            }
            catch (Exception exe)
            {

            }

        }



        private void dataGridView1_SelectionChanged(object sender, EventArgs e)
        {

        }

        private void radioButton1_CheckedChanged(object sender, EventArgs e)
        {
            PanelScroll = false;
            Modify_lock_add = false;
            Modify_lock = true;
        }

        private void radioButton2_CheckedChanged(object sender, EventArgs e)
        {
            Modify_lock = false;
            PanelScroll = false;
            Modify_lock_add = true;

        }

        private void radioButton3_CheckedChanged(object sender, EventArgs e)
        {
            PanelScroll = true;
            Modify_lock = false;
            Modify_lock_add = false;
        }

        private void Form1_SizeChanged(object sender, EventArgs e)
        {
            panel1.SetBounds(0, 0, 1040, Size.Height);
        }

        private void Form1_Scroll(object sender, ScrollEventArgs e)
        {

        }

        private void imageBox1_SizeChanged(object sender, EventArgs e)
        {


        }

        private void button10_Click_1(object sender, EventArgs e)
        {

        }

        private void button11_Click_1(object sender, EventArgs e)
        {

        }

        private void button12_Click_1(object sender, EventArgs e)
        {

        }

        private void button13_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Image<Bgr, byte> Displaybgr = new Image<Bgr, byte>(LockImage.Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(1040, 1040);
                for (int i = 0; i < Displaybgr.Width; i++)
                {
                    for (int j = 0; j < Displaybgr.Height; j++)
                    {
                        if (Displaybgr.Data[j, i, 1] == 255 && Displaybgr.Data[j, i, 2] == 255)
                            Display222.Data[j, i, 0] = 255;
                        if (Displaybgr.Data[j, i, 0] == 255 && Displaybgr.Data[j, i, 1] == 255 && Displaybgr.Data[j, i, 2] == 255)
                            Display222.Data[j, i, 0] = 255;
                    }
                }
                var dst = new Mat();
                XImgprocInvoke.Thinning(Display222, dst, ThinningTypes.GuoHall);
                imageBox1.Image = dst;
                imageBox_otsu.Image = dst;
                Image<Gray, byte> CIR = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> imgA = new Image<Gray, byte>(ori[1].ToBitmap());
                Image<Gray, byte> imgB = new Image<Gray, byte>(CIR.ToBitmap());
                Image<Bgr, byte> img_Displayggg = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
                Image<Gray, byte> imgdisplay = new Image<Gray, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
                Image<Gray, byte> CIR2 = new Image<Gray, byte>(1040, 1040);
                CvInvoke.Circle(CIR2, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255), -1);
                VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存
                VectorOfRect hierarchy = new VectorOfRect();
                CvInvoke.FindContours(imgB, contours_White, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 

                for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {

                    //imgB.SetZero();
                    // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                    double A = CvInvoke.ContourArea(contours_White[i]);
                    // Debug.Print(A.ToString());


                    MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                    int[] Cx = new int[contours_White.Size];  //x座標
                    int[] Cy = new int[contours_White.Size];  //y座標                
                    mom[i] = CvInvoke.Moments(contours_White[i]);
                    Cx[i] = (int)mom[i].GravityCenter.X;
                    Cy[i] = (int)mom[i].GravityCenter.Y;

                    if (A > 25 && A < 60000)
                    {
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                        Point rcenter = new Point(Cx[i], Cy[i]);

                        double W = (int)rotatedRect.Size.Width;
                        double H = (int)rotatedRect.Size.Height;

                        CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(255, 255, 255), -1);

                    }
                }
                //imageBox_otsu.Image = img_Displayggg;
                Image<Gray, byte> CIR3 = new Image<Gray, byte>(img_Displayggg.Bitmap);
                CIR3._Erode(1);
                CIR3._Dilate(1);
                Recover_image = new Image<Bgr, byte>(CIR3.Bitmap);
                Image<Bgr, byte> Display = new Image<Bgr, byte>(CIR3.Bitmap);
                initialDatagrid();

                Image<Bgr, byte> imgDisplay2 = new Image<Bgr, byte>(1040, 1040);
                Image<Bgr, byte> imgC = new Image<Bgr, byte>(ori.Width, ori.Height);
                Image<Gray, byte> CIR5 = new Image<Gray, byte>(Display.Bitmap);
                VectorOfVectorOfPoint contours_White2 = new VectorOfVectorOfPoint();  //找到的輪廓儲存     
                int Count = 0;
                CvInvoke.FindContours(CIR5, contours_White2, null, RetrType.External, ChainApproxMethod.ChainApproxNone);  //找輪廓語法 
                int[] MCV_Global = new int[contours_White2.Size + 1];
                double[] Position_x = new double[contours_White2.Size + 1];
                double[] Position_y = new double[contours_White2.Size + 1];
                double[] width = new double[contours_White2.Size + 1];
                double[] height = new double[contours_White2.Size + 1];

                for (int i = 0; i < contours_White2.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {
                    double AREA = CvInvoke.ContourArea(contours_White2[i]);
                    MCvMoments[] mom = new MCvMoments[contours_White2.Size]; //形心
                    int[] Cx = new int[contours_White2.Size];  //x座標
                    int[] Cy = new int[contours_White2.Size];  //y座標 
                    mom[i] = CvInvoke.Moments(contours_White2[i]);
                    Cx[i] = (int)mom[i].GravityCenter.X;
                    Cy[i] = (int)mom[i].GravityCenter.Y;
                    if (AREA > (double)Threshold_Area.Value && AREA < 90000)
                    {

                        Rectangle rect = CvInvoke.BoundingRectangle(contours_White2[i]);
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White2[i]);
                        Point rcenter = new Point(Cx[i], Cy[i]);
                        double A = (int)rotatedRect.Size.Width;
                        double B = (int)rotatedRect.Size.Height;
                        if (Math.Round(B / A, 1) < (double)W_HRate_defect.Value && AREA / (A * B * Math.PI) > (double)RoundShape.Value / 100)
                        {
                            CvInvoke.DrawContours(imgDisplay2, contours_White2, i, new MCvScalar(0, 255, 255), 1);
                            CvInvoke.DrawContours(imgC, contours_White2, i, new MCvScalar(255, 255, 255), -1);
                            CvInvoke.DrawContours(imgdisplay, contours_White2, i, new MCvScalar(255, 255, 255), -1);
                        }

                    }
                }

                imgA = imgA.And(imgdisplay);
                for (int i = 0; i < contours_White2.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {
                    double AREA = CvInvoke.ContourArea(contours_White2[i]);
                    MCvMoments[] mom = new MCvMoments[contours_White2.Size]; //形心
                    int[] Cx = new int[contours_White2.Size];  //x座標
                    int[] Cy = new int[contours_White2.Size];  //y座標 
                    mom[i] = CvInvoke.Moments(contours_White2[i]);
                    Cx[i] = (int)mom[i].GravityCenter.X;
                    Cy[i] = (int)mom[i].GravityCenter.Y;
                    if (AREA > (double)Threshold_Area.Value && AREA < 90000)
                    {

                        Rectangle rect = CvInvoke.BoundingRectangle(contours_White2[i]);
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White2[i]);
                        Point rcenter = new Point(Cx[i], Cy[i]);
                        double A = (int)rotatedRect.Size.Width;
                        double B = (int)rotatedRect.Size.Height;
                        if (Math.Round(B / A, 1) < (double)W_HRate_defect.Value && AREA / (A * B * Math.PI) > (double)RoundShape.Value / 100)
                        {

                            if (number_visible.Checked)
                                CvInvoke.PutText(imgDisplay2, (Count + 1).ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 2);
                            Position_x[Count] = (double)rect.X;
                            Position_y[Count] = (double)rect.Y;
                            width[Count] = (double)rect.Width;
                            height[Count] = (double)rect.Height;
                            Image<Gray, byte> temp = new Image<Gray, byte>((int)width[Count], (int)height[Count]);

                            for (int a = 0; a < width[Count] - 1; a++)
                            {
                                for (int b = 0; b < height[Count] - 1; b++)
                                {
                                    if (imgA.Data[(int)Position_y[Count] + b, (int)Position_x[Count] + a, 0] == 0)
                                    {

                                    }
                                    else
                                    {
                                        temp.Data[b, a, 0] = imgA.Data[(int)Position_y[Count] + b, (int)Position_x[Count] + a, 0];
                                    }
                                }
                            }

                            MCV_Global[Count] = (int)ImgMean(temp);

                            //CvInvoke.Circle(imgDisplay2, new System.Drawing.Point(Cx[i], Cy[i]), 5, new MCvScalar(0, 0, 255), -1);
                            dataGridView1.Rows.Add((Count + 1).ToString(), ((int)AREA).ToString(), Math.Round(B / A, 1).ToString(), Math.Round((int)AREA / (B * A * Math.PI) * 4, 2).ToString(), MCV_Global[Count].ToString());
                            Count++;
                        }

                    }
                }
                try
                {
                    int total_mean = 0;
                    double st_deviation = 0;
                    for (int c = 1; c < Count + 1; c++)
                    {
                        total_mean = total_mean + MCV_Global[c];
                    }
                    averange_display.Text = ((int)(total_mean / Count)).ToString();

                    for (int c = 1; c < Count + 1; c++)
                    {
                        st_deviation = st_deviation + Math.Sqrt(Math.Pow(MCV_Global[c] - (total_mean / Count), 2) / Count);
                    }
                    st_display.Text = ((int)st_deviation).ToString();

                    Save_Contour_image = imgC;

                    imageBox1.Image = imgDisplay2.Or(ori);
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.ToString());
                }

            }
        }

        private void button14_Click_1(object sender, EventArgs e)
        {

        }

        private void Circle_Filter_Scroll(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                lbl_circlr_filter.Text = Circle_Filter.Value.ToString();
                button8_Click(sender, e);
                Image<Bgr, byte> Display222 = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                CvInvoke.Circle(Display222, new Point(Ori_x, Ori_y), 3, new MCvScalar(0, 255, 255), -1);
                CvInvoke.Circle(Display222, new Point(Ori_x, Ori_y), Circle_Filter.Value, new MCvScalar(0, 255, 255));
                imageBox1.Image = Display222;
            }

        }

        private void button16_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(imageBox1.Image.Bitmap);

                imageBox1.Image = Display222.SmoothMedian((int)smooth_v.Value);
            }
        }

        private void button18_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Displaybgr = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(1040, 1040);
                for (int i = 0; i < Displaybgr.Width; i++)
                {
                    for (int j = 0; j < Displaybgr.Height; j++)
                    {
                        if (Displaybgr.Data[j, i, 1] == 255 && Displaybgr.Data[j, i, 2] == 255)
                            Display222.Data[j, i, 0] = 255;
                        if (Displaybgr.Data[j, i, 0] == 255 && Displaybgr.Data[j, i, 1] == 255 && Displaybgr.Data[j, i, 2] == 255)
                            Display222.Data[j, i, 0] = 255;
                    }
                }
                var dst = new Mat();
                XImgprocInvoke.Thinning(Display222, dst, ThinningTypes.GuoHall);
                imageBox1.Image = dst;
            }

        }

        private void button19_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> CIR = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> imgA = new Image<Bgr, byte>(CIR.ToBitmap());
                Image<Gray, byte> imgB = new Image<Gray, byte>(CIR.ToBitmap());
                Image<Bgr, byte> img_Display = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
                Image<Bgr, byte> img_Displayggg = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
                Image<Gray, byte> CIR2 = new Image<Gray, byte>(1040, 1040);
                Point seed = new Point(0, 0);
                Rectangle RR = new Rectangle(0, 0, 0, 0);
                CvInvoke.Circle(CIR2, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255), -1);

                VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存



                VectorOfRect hierarchy = new VectorOfRect();

                CvInvoke.FindContours(imgB, contours_White, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 



                String[] Color_R = new String[contours_White.Size];
                for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {

                    //imgB.SetZero();
                    // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                    double A = CvInvoke.ContourArea(contours_White[i]);
                    // Debug.Print(A.ToString());


                    MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                    int[] Cx = new int[contours_White.Size];  //x座標
                    int[] Cy = new int[contours_White.Size];  //y座標                
                    mom[i] = CvInvoke.Moments(contours_White[i]);
                    Cx[i] = (int)mom[i].GravityCenter.X;
                    Cy[i] = (int)mom[i].GravityCenter.Y;
                    if (A > 25 && A < 35000)
                    {
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                        Point rcenter = new Point(Cx[i], Cy[i]);

                        double W = (int)rotatedRect.Size.Width;
                        double H = (int)rotatedRect.Size.Height;

                        CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(255, 255, 255), -1);
                        //if (hierarchy[i].Height != -1)
                        //{
                        //    CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(0, 0, 0), -1);
                        //}


                        //CvInvoke.PutText(img_Display, Color_R[i].ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);

                    }
                    //for (int i = 0; i < contours_Useless.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                    //{

                    //        CvInvoke.DrawContours(img_Display2, contours_Useless, i, new MCvScalar(255, 255, 255), -1);
                    //    //CvInvoke.PutText(img_Display, Color_R[i].ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);
                    //}
                    //img_Display._And(oriForever);
                    imageBox1.Image = img_Displayggg;
                    //CvInvoke.FloodFill(img_Display, img_Displayggg, seed, new MCvScalar(255,255,255), out RR, new MCvScalar(0, 0,0),new MCvScalar(255, 255, 255));


                }


            }
        }

        private void button20_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> CIRCIR = new Image<Gray, byte>(1040, 1040);

                //CvInvoke.Threshold(Display222, Display222, 0, 255, ThresholdType.Otsu);
                //CvInvoke.Circle(Display222, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255), -1);
                imageBox1.Image = Display222.Add(gray1);

            }
        }

        private void button21_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);//復原的圖
                Image<Bgr, byte> CIR = new Image<Bgr, byte>(imageBox1.Image.Bitmap);//將Imagebox1中的圖片提取出來的彩圖
                Image<Bgr, byte> circle = new Image<Bgr, byte>(1040, 1040);//將Imagebox1中的圖片提取出來的彩圖
                Image<Gray, byte> circle_gray = new Image<Gray, byte>(1040, 1040);//將Imagebox1中的圖片提取出來的彩圖
                Image<Gray, byte> oriii = new Image<Gray, byte>(Pattern_G.Bitmap);//將G層當作原灰階圖層
                Image<Bgr, byte> B_image = new Image<Bgr, byte>(Pattern_G.Bitmap);//創造G層的彩圖
                Image<Gray, byte> Gradient_test = new Image<Gray, byte>(1040, 1040);//創造過濾動脈血管的灰階層
                Image<Gray, byte> Gradient_test_ori = new Image<Gray, byte>(1040, 1040);//創造原方法過濾動脈血管的灰階層
                Image<Bgr, byte> Last = new Image<Bgr, byte>(1040, 1040);//創造最後的彩圖
                Image<Bgr, byte> Last_ori = new Image<Bgr, byte>(1040, 1040);//創造最後原方法的彩圖


                //B_image._EqualizeHist();//對G層做直方圖等化
                //B_image._GammaCorrect((double)Gamma_value.Value);//對G層做Gamma校正，數值1.8

                Image<Gray, byte> B_image_gray = new Image<Gray, byte>(oriii.Bitmap);//創造灰層，複製原本已做完直方圖等化+Gamma校正後的G層，為了要做otsu二直化的灰層黑白圖
                                                                                     //B_image_gray = B_image_gray.Dilate(1);
                MCvScalar MCV = CvInvoke.Mean(B_image_gray);//找尋灰階圖中的平均Mean值
                CvInvoke.Threshold(B_image_gray, B_image_gray, OtsuImg(B_image_gray, (int)MCV.V0 + 15, 35), 255, ThresholdType.Binary);


                //B_image_gray = B_image_gray.Dilate(2);//
                Image<Bgr, byte> BGR_image_gray = new Image<Bgr, byte>(B_image_gray.Bitmap);
                BGR_image_gray._And(ori);


                Image<Gray, byte> B = new Image<Gray, byte>(BGR_image_gray.Bitmap);
                B = B.SmoothMedian((int)smooth_v.Value);
                //B_image_gray = new Image<Gray, byte>(BGR_image_gray.Bitmap);
                //CvInvoke.Threshold(B_image_gray, B_image_gray, 0, 255, ThresholdType.Otsu);//對灰層做otsu二直化的灰層黑白圖

                //B_image = B_image.SmoothMedian((int)smooth_v.Value);//已做完直方圖等化+Gamma校正後的G層做平滑處理
                //oriii = oriii.SmoothMedian((int)smooth_v.Value);//原灰階圖層做平滑處理

                for (int i = 2; i < B.Width - 2; i = i + 1)
                {
                    for (int j = 2; j < B.Height - 2; j = j + 1)//對整張圖去做檢視
                    {
                        int data = 0;
                        for (int w = -2; w < 3; w++)
                        {
                            for (int t = -2; t < 3; t++)//做5X5梯度變化的灰階疊加
                            {
                                if (B.Data[j + t, i + w, 0] == 0 || B.Data[j, i, 0] == 0)//條件為判斷梯度的像素灰階不能為0
                                {

                                }
                                else
                                {
                                    data += ((int)(Math.Abs((int)(B.Data[j + t, i + w, 0] - B.Data[j, i, 0]))));
                                    if (data > 255)
                                        Gradient_test.Data[j, i, 0] = 255;
                                    else
                                        Gradient_test.Data[j, i, 0] = (byte)data;
                                    //Gradient_test.Data[j, i, 0] += ((Byte)(Math.Abs((int)(oriii.Data[j + t, i + w, 0] - oriii.Data[j, i, 0]))));//取原灰階G層做梯度變化圖，為了要使用Edge Link

                                }

                            }
                        }

                    }
                }

                Image<Gray, byte> Gradient_test_dst = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                MCvScalar MCV2 = CvInvoke.Mean(Gradient_test);
                //imageBox_otsu.Image = Gradient_test;
                CvInvoke.Threshold(Gradient_test, Gradient_test, OtsuImg(Gradient_test, (int)MCV2.V0 + 15, 35), 255, ThresholdType.Binary);

                //imageBox1.Image = Gradient_test_dst;
                var dsttest = new Mat();
                XImgprocInvoke.Thinning(Gradient_test, dsttest, ThinningTypes.GuoHall);
                imageBox1.Image = dsttest;

                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);

                if (Connect_Switch.Checked)
                {
                    ColorPint(ref Connect_img);
                    ConnectedLine(ref Connect_img);
                }
                else
                { }

                Image<Gray, byte> Connect_img_gray = new Image<Gray, byte>(Connect_img.Bitmap);
                //Image<Gray, byte> Gradient_test_dst = new Image<Gray, byte>(imageBox1.Image.Bitmap);

                Image<Gray, byte> Otsu_ori_gray = new Image<Gray, byte>(oriii.Bitmap);
                Image<Gray, byte> Otsu_ori_gray2 = new Image<Gray, byte>(oriii.Bitmap);

                MCvScalar MCV3 = CvInvoke.Mean(Otsu_ori_gray);
                CvInvoke.Threshold(Otsu_ori_gray, Otsu_ori_gray, OtsuImg(Otsu_ori_gray, (int)MCV3.V0 + 15, 35), 255, ThresholdType.Binary);
                //CvInvoke.Threshold(Otsu_ori_gray2, Otsu_ori_gray2, OtsuImg(Otsu_ori_gray2, (int)MCV3.V0 + 55, 35), 255, ThresholdType.Binary);
                //var dsttest2 = new Mat();
                //XImgprocInvoke.Thinning(Otsu_ori_gray2.Erode(3), dsttest2, ThinningTypes.GuoHall);
                //imageBox1.Image = dsttest2;
                //Image<Gray, byte> Thin_sub = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                //Image<Bgr, byte> Thin_sub_Bgr = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                if (Allow_open.Checked)
                {
                    Otsu_ori_gray = Otsu_ori_gray.Dilate(1);
                    Otsu_ori_gray = Otsu_ori_gray.Erode(1);
                }
                if (Connect_Switch.Checked)
                {
                    Otsu_ori_gray = Otsu_ori_gray.Erode(2);
                    //Otsu_ori_gray = Otsu_ori_gray.Dilate(1);
                }
                //imageBox_otsu.Image = Connect_img_gray.Dilate(1);
                Image<Bgr, byte> Otsu_ori = new Image<Bgr, byte>(Otsu_ori_gray.Bitmap);
                Otsu_ori_gray = Otsu_ori_gray.Sub(Connect_img_gray.Dilate(1));
                Otsu_ori = Otsu_ori.Sub(Connect_img.Dilate(1));


                CvInvoke.Circle(circle, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255, 255, 255), -1);
                CvInvoke.Circle(circle_gray, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255), -1);
                VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存


                for (int i = 0; i < Otsu_ori_gray.Width; i++)
                {
                    for (int j = 0; j < Otsu_ori_gray.Height; j++)
                    {
                        if (Math.Sqrt(Math.Pow(i - 520, 2) + Math.Pow(j - 520, 2)) - 520 > 0)
                        {
                            Otsu_ori_gray.Data[j, i, 0] = 0;
                        }
                    }
                }
                VectorOfRect hierarchy = new VectorOfRect();

                if (Allow_Circle.Checked)
                    CvInvoke.FindContours(Otsu_ori_gray.Add(circle_gray), contours_White, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 
                else
                    CvInvoke.FindContours(Otsu_ori_gray, contours_White, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 

                //imageBox_otsu.Image = circle_gray;
                for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {

                    //imgB.SetZero();
                    // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                    double A = CvInvoke.ContourArea(contours_White[i]);
                    // Debug.Print(A.ToString());


                    MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                    int[] Cx = new int[contours_White.Size];  //x座標
                    int[] Cy = new int[contours_White.Size];  //y座標                
                    mom[i] = CvInvoke.Moments(contours_White[i]);
                    Cx[i] = (int)mom[i].GravityCenter.X;
                    Cy[i] = (int)mom[i].GravityCenter.Y;
                    if (A > 25)
                    {
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                        Point rcenter = new Point(Cx[i], Cy[i]);

                        double W = (int)rotatedRect.Size.Width;
                        double H = (int)rotatedRect.Size.Height;
                        if (A > (double)Area_Flower.Value && A < 1000000)
                        {
                            if (H / W > (double)W_Hrate.Value)
                            {
                                //CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(255, 255, 255), 3);
                                //找輪廓語法 
                                CvInvoke.DrawContours(Last, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                if (hierarchy[i].Height != -1)
                                {
                                    CvInvoke.DrawContours(Last, contours_White, i, new MCvScalar(0, 0, 0), -1);
                                }
                                //seed = new Point(Cx[i], Cy[i]);
                            }
                            else
                            {
                                if (A > 20000)
                                {
                                    CvInvoke.DrawContours(Last, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                    if (hierarchy[i].Height != -1)
                                    {
                                        CvInvoke.DrawContours(Last, contours_White, i, new MCvScalar(0, 0, 0), -1);
                                    }
                                }
                            }


                        }
                        else
                        {
                            {

                                if (H / W > (double)W_Hrate.Value)
                                {
                                    CvInvoke.DrawContours(Last, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                    if (hierarchy[i].Height != -1)
                                    {
                                        CvInvoke.DrawContours(Last, contours_White, i, new MCvScalar(0, 0, 0), -1);
                                    }
                                }


                                if (A > 1000000)
                                {
                                    Last = Otsu_ori;
                                }
                            }

                        }


                        //CvInvoke.PutText(img_Display, Color_R[i].ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);

                    }


                }
                //imageBox_otsu.Image = Last.Dilate(4);
                Last = Last.Dilate(4).And(ori);
                Image<Gray, byte> CIR3 = new Image<Gray, byte>(Last.Bitmap);
                CvInvoke.Threshold(CIR3, gray, 0, 255, ThresholdType.Otsu);
                CvInvoke.Threshold(gray, gray, 0, 255, ThresholdType.BinaryInv);
                Image<Bgr, byte> grayy = new Image<Bgr, byte>(gray.Bitmap);
                grayy._And(ori);
                Save_subPic_gray = new Image<Gray, byte>(grayy.Bitmap);
                Save_subPic = new Image<Bgr, byte>(grayy.Bitmap);
                Save_subPic._And(ori);
                imageBox1.Image = Save_subPic;



            }

        }
        private void ProcessImage(Image<Gray, byte> img, Image<Gray, byte> B_img, ref Image<Bgr, byte> Last_img, ref Image<Gray, byte> saveimage)
        {
            Image<Bgr, byte> imgA = new Image<Bgr, byte>(B_img.Sub(img).ToBitmap());
            Image<Gray, byte> imgB = new Image<Gray, byte>(B_img.Sub(img).ToBitmap());
            Image<Bgr, byte> img_Display = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
            Image<Bgr, byte> img_Displayggg = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
            Image<Gray, byte> CIR2 = new Image<Gray, byte>(1040, 1040);
            gray1 = img;
            CvInvoke.Circle(CIR2, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255), -1);

            VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存


            for (int i = 0; i < imgB.Width; i++)
            {
                for (int j = 0; j < imgB.Height; j++)
                {
                    if (Math.Sqrt(Math.Pow(i - 520, 2) + Math.Pow(j - 520, 2)) - 518 > 0)
                    {
                        imgB.Data[j, i, 0] = 0;
                    }
                }
            }
            VectorOfRect hierarchy = new VectorOfRect();

            if (Allow_Circle.Checked)
                CvInvoke.FindContours(imgB.Add(CIR2), contours_White, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 
            else
                CvInvoke.FindContours(imgB, contours_White, hierarchy, RetrType.Ccomp, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 



            String[] Color_R = new String[contours_White.Size];
            for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
            {

                //imgB.SetZero();
                // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                double A = CvInvoke.ContourArea(contours_White[i]);
                // Debug.Print(A.ToString());


                MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                int[] Cx = new int[contours_White.Size];  //x座標
                int[] Cy = new int[contours_White.Size];  //y座標                
                mom[i] = CvInvoke.Moments(contours_White[i]);
                Cx[i] = (int)mom[i].GravityCenter.X;
                Cy[i] = (int)mom[i].GravityCenter.Y;
                if (A > 20)
                {
                    RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                    Point rcenter = new Point(Cx[i], Cy[i]);

                    double W = (int)rotatedRect.Size.Width;
                    double H = (int)rotatedRect.Size.Height;
                    if (A > (double)Area_Flower.Value && A < 1000000)
                    {
                        if (H / W > (double)W_Hrate.Value)
                        {

                            CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(255, 255, 255), -1);

                            if (hierarchy[i].Height != -1)
                            {
                                CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(0, 0, 0), -1);
                            }
                        }
                        else
                        {
                            if (A > 20000)
                            {
                                CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                if (hierarchy[i].Height != -1)
                                {
                                    CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(0, 0, 0), -1);
                                }
                            }
                        }


                    }
                    else
                    {
                        {

                            if (H / W > (double)W_Hrate.Value)
                            {
                                CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(255, 255, 255), -1);
                                if (hierarchy[i].Height != -1)
                                {

                                    CvInvoke.DrawContours(img_Display, contours_White, i, new MCvScalar(0, 0, 0), -1);
                                }
                            }


                            if (A > 1000000)
                            {
                                img_Display = imgA;
                            }
                        }

                    }


                    //CvInvoke.PutText(img_Display, Color_R[i].ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);

                }
                //for (int i = 0; i < contours_Useless.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                //{

                //        CvInvoke.DrawContours(img_Display2, contours_Useless, i, new MCvScalar(255, 255, 255), -1);
                //    //CvInvoke.PutText(img_Display, Color_R[i].ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 1, new MCvScalar(0, 0, 0), 1);
                //}

            }
            img_Display._And(oriForever);
            //CvInvoke.FloodFill(img_Display, img_Displayggg, seed, new MCvScalar(255,255,255), out RR, new MCvScalar(0, 0,0),new MCvScalar(255, 255, 255));
            Image<Gray, byte> Display222 = new Image<Gray, byte>(img_Display.Bitmap);
            CvInvoke.Threshold(Display222, Display222, 0, 255, ThresholdType.Otsu);
            //gray = new Image<Gray, byte>(Display222.Add(gray1).Bitmap);




            Image<Gray, byte> CIR3 = new Image<Gray, byte>(Display222.Bitmap);
            CvInvoke.Threshold(CIR3, gray, 0, 255, ThresholdType.Otsu);
            CvInvoke.Threshold(gray, gray, 0, 255, ThresholdType.BinaryInv);
            Image<Bgr, byte> grayy = new Image<Bgr, byte>(gray.Erode(4).Bitmap);
            grayy._And(ori);
            //grayy._EqualizeHist();
            //grayy._GammaCorrect((double)Gamma_value.Value);
            saveimage = new Image<Gray, byte>(grayy.Bitmap);
            Save_subPic = new Image<Bgr, byte>(grayy.Bitmap);
            Save_subPic._And(ori);
            Last_img = new Image<Bgr, byte>(grayy.Bitmap);
            Last_img._And(ori);

            //imageBox1.Image = Save_subPic;
        }
        private void thresholdvalue_max_Scroll(object sender, ScrollEventArgs e)
        {
            ThreadValue_max.Text = thresholdvalue_max.Value.ToString();
        }

        private void button23_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                imageBox1.Image = Display222.Sub(CannyMeddle);

            }
        }

        private void imageBox1_MouseDoubleClick(object sender, MouseEventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                button8_Click(sender, e);
                Ori_x = e.X;
                Ori_y = e.Y;
                Circle_location.Text = "(" + Ori_x.ToString() + "," + Ori_y.ToString() + ")";
                Image<Bgr, byte> Display222 = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                CvInvoke.Circle(Display222, new Point(Ori_x, Ori_y), 3, new MCvScalar(0, 255, 255), -1);
                CvInvoke.Circle(Display222, new Point(Ori_x, Ori_y), Circle_Filter.Value, new MCvScalar(0, 255, 255));
                imageBox1.Image = Display222;
            }
        }

        private void button24_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> CIR = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Display = new Image<Bgr, byte>(CIR.Bitmap);
                initialDatagrid();
                Image<Bgr, byte> imgxx = new Image<Bgr, byte>(ori.Bitmap);
                Image<Bgr, byte> imgB = new Image<Bgr, byte>(1040, 1040);
                Image<Bgr, byte> imgC = new Image<Bgr, byte>(ori.Width, ori.Height);
                Image<Gray, byte> CIR5 = new Image<Gray, byte>(Display.Bitmap);
                VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存     
                int Count = 0;
                CvInvoke.FindContours(CIR5, contours_White, null, RetrType.External, ChainApproxMethod.ChainApproxNone);  //找輪廓語法 
                for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {
                    double AREA = CvInvoke.ContourArea(contours_White[i]);
                    MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                    int[] Cx = new int[contours_White.Size];  //x座標
                    int[] Cy = new int[contours_White.Size];  //y座標 
                    mom[i] = CvInvoke.Moments(contours_White[i]);
                    Cx[i] = (int)mom[i].GravityCenter.X;
                    Cy[i] = (int)mom[i].GravityCenter.Y;
                    if (AREA > (double)Threshold_Area.Value && AREA < 35000)
                    {

                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);
                        Point rcenter = new Point(Cx[i], Cy[i]);
                        double A = (int)rotatedRect.Size.Width;
                        double B = (int)rotatedRect.Size.Height;
                        if (Math.Round(B / A, 1) < (double)W_HRate_defect.Value && AREA / (A * B * Math.PI) > (double)RoundShape.Value / 100)
                        {
                            Count++;
                            CvInvoke.DrawContours(imgB, contours_White, i, new MCvScalar(0, 255, 255), 1);
                            CvInvoke.DrawContours(imgC, contours_White, i, new MCvScalar(255, 255, 255), -1);
                            if (number_visible.Checked)
                                CvInvoke.PutText(imgB, Count.ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 2);
                            CvInvoke.Circle(imgB, new System.Drawing.Point(Cx[i], Cy[i]), 5, new MCvScalar(0, 0, 255), -1);
                            dataGridView1.Rows.Add(Count.ToString(), ((int)AREA).ToString(), Math.Round(B / A, 1).ToString(), Math.Round((int)AREA / (B * A * Math.PI) * 4, 2).ToString());

                        }

                    }
                }
                Save_Contour_image = imgC;
                imageBox1.Image = imgB.Or(imgxx);
                //imageBox1.Image = imgC;
            }
        }

        private void button25_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                int min_radiun = 5;
                int max_radiun = 15;
                Pen blackPen = new Pen(Color.Black, 1);
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Displaykkk = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                for (int i = 3; i < Display222.Width - 3; i = i + 1)
                {
                    for (int j = 3; j < Display222.Height - 3; j = j + 1)
                    {
                        if (Display222.Data[j, i, 0] == 255)
                        {
                            int count = 0;
                            Point Frontpoint = new Point(0, 0);
                            for (int g = -1; g < 2; g++)
                            {
                                for (int h = -1; h < 2; h++)
                                {
                                    if (Display222.Data[j + h, i + g, 0] == 255)
                                    {
                                        if (h == 0 && g == 0)
                                        {
                                        }
                                        else
                                        {
                                            Frontpoint = new Point(i + g, j + h);
                                            count++;
                                        }

                                        //CvInvoke.Line(Displaykkk, new Point(i + g, j + h), new Point(i, j), new MCvScalar(255, 255, 255));

                                    }
                                }
                            }
                            if (count == 0)
                            {
                                Displaykkk.Data[j, i, 0] = 0;
                                Displaykkk.Data[j, i, 1] = 0;
                                Displaykkk.Data[j, i, 2] = 0;
                            }
                            if (count == 1)
                            {
                                Displaykkk.Data[j, i, 0] = 0;
                                Displaykkk.Data[j, i, 1] = 0;
                                Displaykkk.Data[j, i, 2] = 0;
                                if (i - Frontpoint.X == -1)
                                {
                                    Displaykkk.Data[j, i, 2] = 128;
                                    Displaykkk.Data[j, i, 1] = 128;
                                    Displaykkk.Data[j, i, 0] = 128;
                                }
                                if (j - Frontpoint.Y == 1)
                                {
                                    Displaykkk.Data[j, i, 2] = 255;
                                }
                                if (i - Frontpoint.X == 1)
                                {
                                    Displaykkk.Data[j, i, 0] = 255;
                                }
                                if (j - Frontpoint.Y == -1)
                                {
                                    Displaykkk.Data[j, i, 1] = 255;
                                }
                                //Displaykkk.Data[j + (j - Frontpoint.Y), i + (i - Frontpoint.X), 0] = 0;
                                //Displaykkk.Data[j + (j - Frontpoint.Y), i + (i - Frontpoint.X), 1] = 0;
                                //Displaykkk.Data[j + (j - Frontpoint.Y), i + (i - Frontpoint.X), 2] = 0;
                                //if (i - Frontpoint.X == -1)
                                //{
                                //    Displaykkk.Data[j + (j - Frontpoint.Y), i + (i - Frontpoint.X), 2] = 128;
                                //    Displaykkk.Data[j + (j - Frontpoint.Y), i + (i - Frontpoint.X), 1] = 128;
                                //    Displaykkk.Data[j + (j - Frontpoint.Y), i + (i - Frontpoint.X), 0] = 128;
                                //}
                                //if (j - Frontpoint.Y == 1)
                                //{
                                //    Displaykkk.Data[j + (j - Frontpoint.Y), i + (i - Frontpoint.X), 2] = 255;
                                //}
                                //if (i - Frontpoint.X == 1)
                                //{
                                //    Displaykkk.Data[j + (j - Frontpoint.Y), i + (i - Frontpoint.X), 0] = 255;
                                //}
                                //if (j - Frontpoint.Y == -1)
                                //{
                                //    Displaykkk.Data[j + (j - Frontpoint.Y), i + (i - Frontpoint.X), 1] = 255;
                                //}

                            }
                            //if (count == 3)
                            //{

                            //    Point pp = new Point(0, 0);
                            //    for (int g = -1; g < 2; g++)
                            //    {
                            //        for (int h = -1; h < 2; h++)
                            //        {
                            //            if (Display222.Data[j + h, i + g, 0] == 255)
                            //            {
                            //                if (h == 0 && g == 0)
                            //                {

                            //                }
                            //                else
                            //                {
                            //                    if (h == 0 || g == 0)
                            //                    {

                            //                        if (Math.Abs(pp.Y - (j + h)) == 1 && Math.Abs(pp.X - (i + g)) == 1)
                            //                        {

                            //                            Displaykkk.Data[j , i , 0] = 0;
                            //                            Displaykkk.Data[j , i , 1] = 0;
                            //                            Displaykkk.Data[j , i , 2] = 0;
                            //                        }
                            //                        else
                            //                            pp = new Point(i + g, j + h);
                            //                    }
                            //                    else
                            //                    {

                            //                    }

                            //                }

                            //                //CvInvoke.Line(Displaykkk, new Point(i + g, j + h), new Point(i, j), new MCvScalar(255, 255, 255));

                            //            }
                            //        }
                            //    }
                            //}
                            //if (count == 4)
                            //{
                            //    CvInvoke.Circle(Displaykkk, new Point(i, j), 2, new MCvScalar(0, 0, 0), -1);
                            //}
                            //if (count >= 3)
                            //{
                            //    Displaykkk.Data[j, i, 0] = 200;
                            //    Displaykkk.Data[j, i, 1] = 200;
                            //    Displaykkk.Data[j, i, 2] = 200;
                            //}
                            //for (int g = -1; g < 2; g++)
                            //{
                            //    for (int h = -1; h < 2; h++)
                            //    {
                            //        if (Displaykkk.Data[j + (j - Frontpoint.Y) + h, i + (i - Frontpoint.X) + g, 0] == 255)
                            //        { }
                            //        else
                            //        {
                            //            Displaykkk.Data[j + (j - Frontpoint.Y) + h, i + (i - Frontpoint.X) + g, 0] = Display222.Data[Frontpoint.Y + h, Frontpoint.X + g, 0];
                            //            Displaykkk.Data[j + (j - Frontpoint.Y) + h, i + (i - Frontpoint.X) + g, 1] = Display222.Data[Frontpoint.Y + h, Frontpoint.X + g, 0];
                            //            Displaykkk.Data[j + (j - Frontpoint.Y) + h, i + (i - Frontpoint.X) + g, 2] =0; 
                            //        }

                            //    }
                            //}

                        }

                    }
                }

                for (int i = 3; i < Displaykkk.Width - 3; i = i + 1)
                {
                    for (int j = 3; j < Displaykkk.Height - 3; j = j + 1)
                    {
                        if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 255)
                        {

                        }
                        else
                        {
                            if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 0)
                            { }
                            else
                            {

                                for (int g = -1; g < 2; g++)
                                {
                                    for (int h = -1; h < 2; h++)
                                    {
                                        if (Displaykkk.Data[j + h, i + g, 0] == 255 && Displaykkk.Data[j + h, i + g, 1] == 255 && Displaykkk.Data[j + h, i + g, 2] == 255)
                                        {

                                        }
                                        else
                                        {
                                            if (Displaykkk.Data[j + h, i + g, 0] == 0 && Displaykkk.Data[j + h, i + g, 1] == 0 && Displaykkk.Data[j + h, i + g, 2] == 0)
                                            { }
                                            else
                                            {
                                                if (h == 0 && g == 0)
                                                { }
                                                else
                                                {

                                                    Displaykkk.Data[j, i, 0] = 0;
                                                    Displaykkk.Data[j, i, 1] = 0;
                                                    Displaykkk.Data[j, i, 2] = 0;
                                                }

                                            }

                                        }
                                    }
                                }
                            }

                        }
                    }
                }
                imageBox1.Image = Displaykkk;
            }
        }
        private double OtsuImg(Image<Gray, byte> img, double T, double E)
        {
            byte[,,] A = img.Data;
            int[] Histogram = new int[256];
            double m1, m2;
            double delta = 0;
            for (int j = 0; j < img.Height; j++)
            {
                for (int i = 0; i < img.Width; i++)
                {
                    Histogram[A[j, i, 0]]++;
                }
            }
            do
            {
                double Gup1 = 0, Gup2 = 0;
                double Gdown1 = 0, Gdown2 = 0;
                for (int w = 1; w < T; w++)
                {
                    Gup1 = (double)Gup1 + (Histogram[w] * w);
                    Gdown1 += Histogram[w];
                }
                for (int ww = (int)T + 1; ww < 256; ww++)
                {
                    Gup2 = Gup2 + (Histogram[ww] * ww);
                    Gdown2 += Histogram[ww];

                }
                m1 = Gup1 / Gdown1;
                m2 = Gup2 / Gdown2;
                delta = Math.Abs(((m1 + m2) / 2 - T));
                T = (m1 + m2) / 2;


            } while (delta >= E);//False則跳出
            return T;
        }
        private void button26_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> CIR = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> imgA = new Image<Gray, byte>(ori[1].ToBitmap());
                Image<Gray, byte> imgA_otsu = new Image<Gray, byte>(ori[1].ToBitmap());
                Image<Gray, byte> imgB = new Image<Gray, byte>(CIR.ToBitmap());
                Image<Gray, byte> img_Display = new Image<Gray, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
                Image<Bgr, byte> img_Displayggg = new Image<Bgr, byte>(ori.Bitmap);
                Image<Bgr, byte> img_Real = new Image<Bgr, byte>(ori.Bitmap);
                Image<Gray, byte> CIR2 = new Image<Gray, byte>(1040, 1040);
                Image<Bgr, byte> imgC = new Image<Bgr, byte>(1040, 1040);
                CvInvoke.Circle(CIR2, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255), -1);
                initialDatagrid();
                Mat hierarchy = new Mat();
                VectorOfVectorOfPoint contours_Finaaly = new VectorOfVectorOfPoint();  //找到的輪廓儲存
                CvInvoke.FindContours(imgB, contours_Finaaly, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 
                double[] AREA_B = new double[contours_Finaaly.Size];
                int count = 0;
                int total_mean = 0;
                double st_deviation = 0;
                int[] MCV_Global = new int[contours_Finaaly.Size + 1];
                double[] Position_x = new double[contours_Finaaly.Size + 1];
                double[] Position_y = new double[contours_Finaaly.Size + 1];
                double[] width = new double[contours_Finaaly.Size + 1];
                double[] height = new double[contours_Finaaly.Size + 1];
                for (int j = 0; j < contours_Finaaly.Size; j++)  //一個輪廓表示一個物體 //for對所有輪廓
                {
                    double Area = CvInvoke.ContourArea(contours_Finaaly[j]);
                    if (Area > (Double)Threshold_Area.Value)
                    {


                        MCvMoments[] mom = new MCvMoments[contours_Finaaly.Size]; //形心
                        int[] Cx = new int[contours_Finaaly.Size];  //x座標
                        int[] Cy = new int[contours_Finaaly.Size];  //y座標                
                        mom[j] = CvInvoke.Moments(contours_Finaaly[j]);
                        Cx[j] = (int)mom[j].GravityCenter.X;
                        Cy[j] = (int)mom[j].GravityCenter.Y;
                        Rectangle rect = CvInvoke.BoundingRectangle(contours_Finaaly[j]);
                        Point rcenter = new Point((int)rect.X, (int)rect.Y);
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_Finaaly[j]);

                        double A = (int)rotatedRect.Size.Width;
                        double B = (int)rotatedRect.Size.Height;
                        if (Math.Round(B / A, 1) < (double)W_HRate_defect.Value && Area / (A * B * Math.PI) > (double)RoundShape.Value / 100)
                        {
                            Position_x[count] = (double)rect.X;
                            Position_y[count] = (double)rect.Y;
                            width[count] = (double)rect.Width;
                            height[count] = (double)rect.Height;
                            count++;
                            CvInvoke.DrawContours(img_Display, contours_Finaaly, j, new MCvScalar(255, 255, 255), -1);
                            //CvInvoke.PutText(imgA, OtsuImg(temp,128,10).ToString(), new System.Drawing.Point(Cx[j], Cy[j]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 2);
                        }
                    }

                }
                imgA = imgA.And(img_Display);

                for (int c = 0; c < count; c++)
                {
                    Image<Gray, byte> temp = new Image<Gray, byte>((int)width[c], (int)height[c]);
                    Image<Gray, byte> temp_dst = new Image<Gray, byte>((int)width[c], (int)height[c]);
                    for (int i = 0; i < width[c] - 1; i++)
                    {
                        for (int j = 0; j < height[c] - 1; j++)
                        {
                            if (imgA.Data[(int)Position_y[c] + j, (int)Position_x[c] + i, 0] == 0)
                            {

                            }
                            else
                            {
                                temp.Data[j, i, 0] = imgA.Data[(int)Position_y[c] + j, (int)Position_x[c] + i, 0];
                            }
                        }
                    }
                    //MCvScalar MCV = CvInvoke.Mean(temp);
                    MCV_Global[c] = (int)ImgMean(temp);
                    //ImgMean_Img(temp).Save("C:/Users/K501/Desktop/1/"+c.ToString() + ".jpg");
                    //if (c == 1)
                    //    imageBox1.Image = ImgMean_Img(temp);

                    total_mean = total_mean + MCV_Global[c];
                    //CvInvoke.PutText(img_Displayggg, MCV_Global[c].ToString(), new System.Drawing.Point((int)Position_x[c], (int)Position_y[c]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 2);

                }
                averange_display.Text = ((int)(total_mean / count)).ToString();

                for (int c = 0; c < count; c++)
                {
                    st_deviation = st_deviation + Math.Sqrt(Math.Pow(MCV_Global[c] - (total_mean / count), 2) / count);
                }
                st_display.Text = ((int)st_deviation).ToString();
                for (int c = 0; c < count; c++)
                {
                    Image<Gray, byte> temp = new Image<Gray, byte>((int)width[c], (int)height[c]);
                    Image<Gray, byte> temp_dst = new Image<Gray, byte>((int)width[c], (int)height[c]);
                    int Size_image = (int)width[c] * (int)height[c];
                    int Whitepoint = 0;


                    for (int i = 0; i < width[c] - 1; i++)
                    {
                        for (int j = 0; j < height[c] - 1; j++)
                        {
                            if (imgA.Data[(int)Position_y[c] + j, (int)Position_x[c] + i, 0] == 0)
                            {

                            }
                            else
                            {
                                if (MCV_Global[c] > (total_mean / count) - (double)standard_diff.Value * st_deviation)
                                {
                                    temp.Data[j, i, 0] = imgA.Data[(int)Position_y[c] + j, (int)Position_x[c] + i, 0];

                                }
                                else
                                {
                                    temp.Data[j, i, 0] = 0;
                                }

                            }
                        }
                    }

                    CvInvoke.Threshold(temp, temp_dst, 0, 255, ThresholdType.Binary);
                    //MessageBox.Show(MCV.V0.ToString());
                    for (int w = 0; w < width[c] - 1; w++)
                    {
                        for (int k = 0; k < height[c] - 1; k++)
                        {
                            if (temp_dst.Data[k, w, 0] == 0)
                                imgA_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = 0;
                            else
                                imgA_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = temp_dst.Data[k, w, 0];
                        }
                    }


                }

                int Count = 0;
                int Count2 = 0;
                CvInvoke.Threshold(imgA_otsu.And(img_Display), imgA_otsu, 0, 255, ThresholdType.Binary);
                VectorOfVectorOfPoint contours_kk = new VectorOfVectorOfPoint();  //找到的輪廓儲存
                imgA_otsu = imgA_otsu.Sub(CIR2).Erode(1).Dilate(1);
                CvInvoke.FindContours(imgA_otsu, contours_kk, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 

                for (int j = 0; j < contours_kk.Size; j++)  //一個輪廓表示一個物體 //for對所有輪廓
                {
                    double Area2 = CvInvoke.ContourArea(contours_kk[j]);
                    if (Area2 > (Double)Threshold_Area.Value)
                    {
                        //RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_kk[j]);
                        MCvMoments[] mom = new MCvMoments[contours_kk.Size]; //形心
                        int[] Cx = new int[contours_kk.Size];  //x座標
                        int[] Cy = new int[contours_kk.Size];  //y座標                
                        mom[j] = CvInvoke.Moments(contours_kk[j]);
                        Cx[j] = (int)mom[j].GravityCenter.X;
                        Cy[j] = (int)mom[j].GravityCenter.Y;
                        Rectangle rect = CvInvoke.BoundingRectangle(contours_kk[j]);
                        Point rcenter = new Point((int)rect.X, (int)rect.Y);
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_kk[j]);

                        double A = (int)rotatedRect.Size.Width;
                        double B = (int)rotatedRect.Size.Height;
                        //double A = (int)rotatedRect.Size.Width;
                        //double B = (int)rotatedRect.Size.Height;


                        CvInvoke.DrawContours(img_Displayggg, contours_kk, j, new MCvScalar(0, 255, 255), 1);
                        CvInvoke.DrawContours(img_Real, contours_kk, j, new MCvScalar(0, 255, 255), 1);
                        CvInvoke.DrawContours(imgC, contours_kk, j, new MCvScalar(255, 255, 255), -1);

                        for (int x = 0; x < contours_kk[j].Size; x = x + 15)
                        {
                            CvInvoke.Circle(img_Displayggg, new Point(contours_kk[j][x].X, contours_kk[j][x].Y), (int)RoundShape.Value, new MCvScalar(255, 255, 255), -1);
                            CvInvoke.Circle(img_Real, new Point(contours_kk[j][x].X, contours_kk[j][x].Y), (int)RoundShape.Value, new MCvScalar(255, 255, 255), -1);
                        }

                        //CvInvoke.Circle(img_Displayggg, new System.Drawing.Point(Cx[j], Cy[j]), 5, new MCvScalar(0, 0, 255), -1);
                        dataGridView1.Rows.Add((Count + 1).ToString(), ((int)Area2).ToString(), Math.Round(B / A, 1).ToString(), Math.Round((int)Area2 / (B * A * Math.PI) * 4, 2).ToString(), MCV_Global[Count2].ToString());
                        //for (int x = 0; x < contours_kk[j].Size; x = x + 15)
                        //{

                        //    CvInvoke.Circle(img_Displayggg, new Point(contours_kk[j][x].X, contours_kk[j][x].Y), 10, new MCvScalar(255, 255, 255), -1);
                        //}
                        if (number_visible.Checked)
                            CvInvoke.PutText(img_Displayggg, (Count + 1).ToString(), new System.Drawing.Point(Cx[j], Cy[j]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(0, 0, 255), 2);
                        Count++;



                    }
                    Count2++;
                }

                Save_Contour_image = imgC;
                LockImage = new Image<Bgr, byte>(img_Real.Bitmap);
                imageBox1.Image = img_Displayggg;

                //CvInvoke.FloodFill(img_Display, img_Displayggg, seed, new MCvScalar(255,255,255), out RR, new MCvScalar(0, 0,0),new MCvScalar(255, 255, 255));
                //button13_Click_1( sender,  e);

            }

        }

        private double ImgMean(Image<Gray, byte> img)
        {
            double Mean = 0;
            double pixels = 0;
            Image<Gray, byte> ori_gray = new Image<Gray, byte>(img.Bitmap);
            Image<Gray, byte> otsu_gray = new Image<Gray, byte>(img.Bitmap);
            MCvScalar mc = CvInvoke.Mean(img);
            CvInvoke.Threshold(ori_gray, ori_gray, OtsuImg(img, (int)mc.V0 + (int)Otsu_Second.Value, 35), 255, ThresholdType.Binary);
            ori_gray = ori_gray.And(img);
            for (int i = 0; i < ori_gray.Width; i++)
            {
                for (int j = 0; j < ori_gray.Height; j++)
                {
                    if (ori_gray.Data[j, i, 0] > 0)
                    {
                        Mean = Mean + (double)ori_gray.Data[j, i, 0];
                        pixels = pixels + 1;
                    }
                }
            }
            //ori_gray.Save("C:/Users/K501/Desktop/1/" + mc.V0.ToString() + ".jpg");
            return Mean / pixels;
        }
        private Image<Gray, byte> ImgMean_Img(Image<Gray, byte> img)
        {
            double Mean = 0;
            double pixels = 0;
            Image<Gray, byte> ori_gray = new Image<Gray, byte>(img.Bitmap);
            Image<Gray, byte> otsu_gray = new Image<Gray, byte>(img.Bitmap);
            MCvScalar mc = CvInvoke.Mean(img);
            CvInvoke.Threshold(ori_gray, ori_gray, OtsuImg(img, (int)mc.V0 + (int)Otsu_Second.Value, 35), 255, ThresholdType.Binary);
            ori_gray = ori_gray.And(img);
            for (int i = 0; i < ori_gray.Width; i++)
            {
                for (int j = 0; j < ori_gray.Height; j++)
                {
                    if (ori_gray.Data[j, i, 0] > 0)
                    {
                        Mean = Mean + (double)ori_gray.Data[j, i, 0];
                        pixels = pixels + 1;
                    }

                }
            }
            return ori_gray;
        }



        private void button29_Click(object sender, EventArgs e)
        {

        }
        private void ColorPint(ref Image<Bgr, byte> img)
        {
            Recover_image = new Image<Bgr, byte>(img.Bitmap);
            Image<Gray, byte> Display222 = new Image<Gray, byte>(img.Bitmap);
            Image<Bgr, byte> Displaykkk = new Image<Bgr, byte>(img.Bitmap);
            for (int i = 3; i < Display222.Width - 3; i = i + 1)
            {
                for (int j = 3; j < Display222.Height - 3; j = j + 1)
                {
                    if (Display222.Data[j, i, 0] == 255)
                    {
                        int count = 0;
                        Point Frontpoint = new Point(0, 0);
                        for (int g = -1; g < 2; g++)
                        {
                            for (int h = -1; h < 2; h++)
                            {
                                if (Display222.Data[j + h, i + g, 0] == 255)
                                {
                                    if (h == 0 && g == 0)
                                    {
                                    }
                                    else
                                    {
                                        Frontpoint = new Point(i + g, j + h);
                                        count++;
                                    }

                                    //CvInvoke.Line(Displaykkk, new Point(i + g, j + h), new Point(i, j), new MCvScalar(255, 255, 255));

                                }
                            }
                        }
                        if (count == 0)
                        {
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                        }
                        if (count == 1)
                        {
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                            if (i - Frontpoint.X == -1)
                            {
                                Displaykkk.Data[j, i, 2] = 128;
                                Displaykkk.Data[j, i, 1] = 128;
                                Displaykkk.Data[j, i, 0] = 128;
                            }
                            if (j - Frontpoint.Y == 1)
                            {
                                Displaykkk.Data[j, i, 2] = 255;
                            }
                            if (i - Frontpoint.X == 1)
                            {
                                Displaykkk.Data[j, i, 0] = 255;
                            }
                            if (j - Frontpoint.Y == -1)
                            {
                                Displaykkk.Data[j, i, 1] = 255;
                            }

                        }

                    }
                }

            }
            for (int i = 3; i < Displaykkk.Width - 3; i = i + 1)
            {
                for (int j = 3; j < Displaykkk.Height - 3; j = j + 1)
                {
                    if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 255)
                    {

                    }
                    else
                    {
                        if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 0)
                        { }
                        else
                        {

                            for (int g = -1; g < 2; g++)
                            {
                                for (int h = -1; h < 2; h++)
                                {
                                    if (Displaykkk.Data[j + h, i + g, 0] == 255 && Displaykkk.Data[j + h, i + g, 1] == 255 && Displaykkk.Data[j + h, i + g, 2] == 255)
                                    {

                                    }
                                    else
                                    {
                                        if (Displaykkk.Data[j + h, i + g, 0] == 0 && Displaykkk.Data[j + h, i + g, 1] == 0 && Displaykkk.Data[j + h, i + g, 2] == 0)
                                        { }
                                        else
                                        {
                                            if (h == 0 && g == 0)
                                            { }
                                            else
                                            {

                                                Displaykkk.Data[j, i, 0] = 0;
                                                Displaykkk.Data[j, i, 1] = 0;
                                                Displaykkk.Data[j, i, 2] = 0;
                                            }

                                        }

                                    }
                                }
                            }
                        }

                    }
                }
            }
            img = Displaykkk;

        }

        private void ColorPoint_red(ref Image<Bgr, byte> img)
        {
            Recover_image = new Image<Bgr, byte>(img.Bitmap);
            Image<Gray, byte> Display222 = new Image<Gray, byte>(img.Bitmap);
            Image<Bgr, byte> Displaykkk = new Image<Bgr, byte>(img.Bitmap);
            for (int i = 3; i < Display222.Width - 3; i = i + 1)
            {
                for (int j = 3; j < Display222.Height - 3; j = j + 1)
                {
                    if (Display222.Data[j, i, 0] == 255)
                    {
                        int count = 0;
                        Point Frontpoint = new Point(0, 0);
                        for (int g = -1; g < 2; g++)
                        {
                            for (int h = -1; h < 2; h++)
                            {
                                if (Display222.Data[j + h, i + g, 0] == 255)
                                {
                                    if (h == 0 && g == 0)
                                    {
                                    }
                                    else
                                    {
                                        Frontpoint = new Point(i + g, j + h);
                                        count++;
                                    }

                                    //CvInvoke.Line(Displaykkk, new Point(i + g, j + h), new Point(i, j), new MCvScalar(255, 255, 255));

                                }
                            }
                        }
                        if (count == 0)
                        {
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                        }
                        if (count == 1)
                        {
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                            Displaykkk.Data[j, i, 2] = 255;
                        }

                    }
                }

            }
            for (int i = 3; i < Displaykkk.Width - 3; i = i + 1)
            {
                for (int j = 3; j < Displaykkk.Height - 3; j = j + 1)
                {
                    if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 255)
                    {

                    }
                    else
                    {
                        if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 0)
                        { }
                        else
                        {

                            for (int g = -1; g < 2; g++)
                            {
                                for (int h = -1; h < 2; h++)
                                {
                                    if (Displaykkk.Data[j + h, i + g, 0] == 255 && Displaykkk.Data[j + h, i + g, 1] == 255 && Displaykkk.Data[j + h, i + g, 2] == 255)
                                    {

                                    }
                                    else
                                    {
                                        if (Displaykkk.Data[j + h, i + g, 0] == 0 && Displaykkk.Data[j + h, i + g, 1] == 0 && Displaykkk.Data[j + h, i + g, 2] == 0)
                                        { }
                                        else
                                        {
                                            if (h == 0 && g == 0)
                                            { }
                                            else
                                            {

                                                Displaykkk.Data[j, i, 0] = 0;
                                                Displaykkk.Data[j, i, 1] = 0;
                                                Displaykkk.Data[j, i, 2] = 0;
                                            }

                                        }

                                    }
                                }
                            }
                        }

                    }
                }
            }
            img = Displaykkk;

        }
        private void ColorPoint_green(ref Image<Bgr, byte> img)
        {
            Recover_image = new Image<Bgr, byte>(img.Bitmap);
            Image<Gray, byte> Display222 = new Image<Gray, byte>(img.Bitmap);
            Image<Bgr, byte> Displaykkk = new Image<Bgr, byte>(img.Bitmap);
            for (int i = 3; i < Display222.Width - 3; i = i + 1)
            {
                for (int j = 3; j < Display222.Height - 3; j = j + 1)
                {
                    if (Display222.Data[j, i, 0] == 255)
                    {
                        int count = 0;
                        Point Frontpoint = new Point(0, 0);
                        for (int g = -1; g < 2; g++)
                        {
                            for (int h = -1; h < 2; h++)
                            {
                                if (Display222.Data[j + h, i + g, 0] == 255)
                                {
                                    if (h == 0 && g == 0)
                                    {
                                    }
                                    else
                                    {
                                        Frontpoint = new Point(i + g, j + h);
                                        count++;
                                    }

                                    //CvInvoke.Line(Displaykkk, new Point(i + g, j + h), new Point(i, j), new MCvScalar(255, 255, 255));

                                }
                            }
                        }
                        if (count == 0)
                        {
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                        }
                        if (count == 1)
                        {
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                            Displaykkk.Data[j, i, 0] = 255;
                            Displaykkk.Data[j, i, 2] = 255;
                        }

                    }
                }

            }
            for (int i = 3; i < Displaykkk.Width - 3; i = i + 1)
            {
                for (int j = 3; j < Displaykkk.Height - 3; j = j + 1)
                {
                    if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 255)
                    {

                    }
                    else
                    {
                        if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 0)
                        { }
                        else
                        {

                            for (int g = -1; g < 2; g++)
                            {
                                for (int h = -1; h < 2; h++)
                                {
                                    if (Displaykkk.Data[j + h, i + g, 0] == 255 && Displaykkk.Data[j + h, i + g, 1] == 255 && Displaykkk.Data[j + h, i + g, 2] == 255)
                                    {

                                    }
                                    else
                                    {
                                        if (Displaykkk.Data[j + h, i + g, 0] == 0 && Displaykkk.Data[j + h, i + g, 1] == 0 && Displaykkk.Data[j + h, i + g, 2] == 0)
                                        { }
                                        else
                                        {
                                            if (h == 0 && g == 0)
                                            { }
                                            else
                                            {

                                                Displaykkk.Data[j, i, 0] = 0;
                                                Displaykkk.Data[j, i, 1] = 0;
                                                Displaykkk.Data[j, i, 2] = 0;
                                            }

                                        }

                                    }
                                }
                            }
                        }

                    }
                }
            }
            img = Displaykkk;

        }
        private void PointRemove(ref Image<Bgr, byte> img, int Count_TIME)
        {
            Recover_image = new Image<Bgr, byte>(img.Bitmap);
            Image<Gray, byte> Display222 = new Image<Gray, byte>(img.Bitmap);
            Image<Bgr, byte> Displaykkk = new Image<Bgr, byte>(img.Bitmap);
            for (int i = 3; i < Display222.Width - 3; i = i + 1)
            {
                for (int j = 3; j < Display222.Height - 3; j = j + 1)
                {
                    if (Display222.Data[j, i, 0] == 255)
                    {
                        int count = 0;
                        for (int g = -1; g < 2; g++)
                        {
                            for (int h = -1; h < 2; h++)
                            {
                                if (Display222.Data[j + h, i + g, 0] == 255)
                                {
                                    if (h == 0 && g == 0)
                                    {
                                    }
                                    else
                                    {
                                        count++;
                                    }

                                    //CvInvoke.Line(Displaykkk, new Point(i + g, j + h), new Point(i, j), new MCvScalar(255, 255, 255));

                                }
                            }
                        }
                        if (count == 0)
                        {
                            //Display222.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                        }
                        if (count == 1)
                        {
                            // Display222.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                        }
                        if (count == 2)
                        {
                            int COUNT_DETECT = 0;
                            int[] M = new int[8];
                            for (int q = -1; q < 2; q++)
                            {
                                for (int w = -1; w < 2; w++)
                                {
                                    if (w == 0 && q == 0)
                                    { }
                                    else
                                    {

                                        if (Displaykkk.Data[j + w, i + q, 2] == 255 && Displaykkk.Data[j + w, i + q, 1] == 255 && Displaykkk.Data[j + w, i + q, 0] == 255)
                                        {
                                            M[COUNT_DETECT] = 1;
                                        }
                                        else
                                        {
                                            M[COUNT_DETECT] = 0;
                                        }
                                        COUNT_DETECT = COUNT_DETECT + 1;
                                    }
                                }
                            }
                            //01、12、24、47、67、56、03、35
                            if ((M[0] == 1 && M[1] == 1) || (M[2] == 1 && M[1] == 1) || (M[2] == 1 && M[4] == 1) || (M[4] == 1 && M[7] == 1) || (M[6] == 1 && M[7] == 1) || (M[5] == 1 && M[6] == 1) || (M[0] == 1 && M[3] == 1) || (M[3] == 1 && M[5] == 1))
                            {
                                //Display222.Data[j, i, 0] = 0;
                                Displaykkk.Data[j, i, 0] = 0;
                                Displaykkk.Data[j, i, 1] = 0;
                                Displaykkk.Data[j, i, 2] = 0;
                            }
                        }
                        //if (count == 3)
                        //{
                        //    int COUNT_DETECT = 0;
                        //    int[] M = new int[8];
                        //    for (int q = -1; q < 2; q++)
                        //    {
                        //        for (int w = -1; w < 2; w++)
                        //        {
                        //            if (w == 0 && q == 0)
                        //            { }
                        //            else
                        //            {

                        //                if (Displaykkk.Data[j + w, i + q, 2] == 255 && Displaykkk.Data[j + w, i + q, 1] == 255 && Displaykkk.Data[j + w, i + q, 0] == 255)
                        //                {
                        //                    M[COUNT_DETECT] = 1;
                        //                }
                        //                else
                        //                {
                        //                    M[COUNT_DETECT] = 0;
                        //                }
                        //                COUNT_DETECT = COUNT_DETECT + 1;
                        //            }
                        //        }
                        //    }
                        //    //012、035、247、567
                        //    if ((M[0] == 1 && M[1] == 1) || (M[2] == 1 && M[1] == 1) || (M[2] == 1 && M[4] == 1) || (M[4] == 1 && M[7] == 1) || (M[6] == 1 && M[7] == 1) || (M[5] == 1 && M[6] == 1) || (M[0] == 1 && M[3] == 1) || (M[3] == 1 && M[5] == 1))
                        //    {
                        //        //Display222.Data[j, i, 0] = 0;
                        //        Displaykkk.Data[j, i, 0] = 0;
                        //        Displaykkk.Data[j, i, 1] = 0;
                        //        Displaykkk.Data[j, i, 2] = 0;
                        //    }
                        //}
                    }
                }


            }


            img = Displaykkk;

        }

        private void Point_sub(ref Image<Bgr, byte> img, int Count_TIME)
        {
            Recover_image = new Image<Bgr, byte>(img.Bitmap);
            Image<Gray, byte> Display222 = new Image<Gray, byte>(img.Bitmap);
            Image<Bgr, byte> Displaykkk = new Image<Bgr, byte>(img.Bitmap);
            for (int i = 3; i < Display222.Width - 3; i = i + 1)
            {
                for (int j = 3; j < Display222.Height - 3; j = j + 1)
                {
                    if (Display222.Data[j, i, 0] == 255)
                    {
                        int count = 0;
                        for (int g = -1; g < 2; g++)
                        {
                            for (int h = -1; h < 2; h++)
                            {
                                if (Display222.Data[j + h, i + g, 0] == 255)
                                {
                                    if (h == 0 && g == 0)
                                    {
                                    }
                                    else
                                    {
                                        count++;
                                    }

                                    //CvInvoke.Line(Displaykkk, new Point(i + g, j + h), new Point(i, j), new MCvScalar(255, 255, 255));

                                }
                            }
                        }
                        if (count == 0)
                        {
                            //Display222.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                        }
                        if (count == 1)
                        {
                            // Display222.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 0] = 0;
                            Displaykkk.Data[j, i, 1] = 0;
                            Displaykkk.Data[j, i, 2] = 0;
                        }
                        if (count == 2)
                        {
                            int COUNT_DETECT = 0;
                            int[] M = new int[8];
                            for (int q = -1; q < 2; q++)
                            {
                                for (int w = -1; w < 2; w++)
                                {
                                    if (w == 0 && q == 0)
                                    { }
                                    else
                                    {

                                        if (Displaykkk.Data[j + w, i + q, 2] == 255 && Displaykkk.Data[j + w, i + q, 1] == 255 && Displaykkk.Data[j + w, i + q, 0] == 255)
                                        {
                                            M[COUNT_DETECT] = 1;
                                        }
                                        else
                                        {
                                            M[COUNT_DETECT] = 0;
                                        }
                                        COUNT_DETECT = COUNT_DETECT + 1;
                                    }
                                }
                            }
                            //01、12、24、47、67、56、03、35
                            if ((M[0] == 1 && M[1] == 1) || (M[2] == 1 && M[1] == 1) || (M[2] == 1 && M[4] == 1) || (M[4] == 1 && M[7] == 1) || (M[6] == 1 && M[7] == 1) || (M[5] == 1 && M[6] == 1) || (M[0] == 1 && M[3] == 1) || (M[3] == 1 && M[5] == 1))
                            {
                                //Display222.Data[j, i, 0] = 0;
                                Displaykkk.Data[j, i, 0] = 0;
                                Displaykkk.Data[j, i, 1] = 0;
                                Displaykkk.Data[j, i, 2] = 0;
                            }
                        }
                    }
                }


            }


            img = Displaykkk;

        }

        private void ConnectedLine(ref Image<Bgr, byte> img)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                int max_radiun = (int)Distance_EdgeLInk.Value; ;
                //Recover_image = new Image<Bgr, byte>(img.Bitmap);
                Image<Bgr, byte> Displaykkk = new Image<Bgr, byte>(img.Bitmap);
                for (int i = max_radiun; i < Displaykkk.Width - max_radiun; i++)
                {
                    for (int j = max_radiun; j < Displaykkk.Height - max_radiun; j++)
                    {
                        if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 255)
                        {

                        }
                        else
                        {
                            if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 0)
                            {

                            }
                            else
                            {
                                int step = 0;
                                int x_step = i;
                                int y_step = j;
                                int x_min = i;
                                int y_min = j;
                                int x_max = i;
                                int y_max = j;
                                Point[] P_pos = new Point[AddOUT((int)Distance_EdgeLInk.Value) + 1];
                                do
                                {
                                    do//up
                                    {
                                        step++;
                                        y_step--;
                                        P_pos[step] = new Point(x_step, y_step);

                                    } while (y_step >= y_min);
                                    y_min = y_step;
                                    do//right
                                    {
                                        step++;
                                        x_step++;
                                        P_pos[step] = new Point(x_step, y_step);
                                    } while (x_step <= x_max);
                                    x_max = x_step;
                                    do//down
                                    {
                                        step++;
                                        y_step++;
                                        P_pos[step] = new Point(x_step, y_step);
                                    } while (y_step <= y_max);
                                    y_max = y_step;
                                    do//left
                                    {
                                        step++;
                                        x_step--;
                                        P_pos[step] = new Point(x_step, y_step);
                                    } while (x_step >= x_min);
                                    x_min = x_step;
                                } while (step < AddOUT((int)Distance_EdgeLInk.Value));
                                if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 0)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 128)
                                        {
                                            if (P_pos[cc].X >= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].X >= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }

                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 128)
                                        {
                                            if (P_pos[cc].X >= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }

                                        }
                                        if (Connect_Line_Serious_chb.Checked)
                                        {

                                        }
                                        else
                                        {
                                            if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 0)
                                            {
                                                {
                                                    if (P_pos[cc].X >= i)
                                                    {
                                                        CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                        goto testout;
                                                    }
                                                }
                                            }
                                        }

                                    }
                                }
                                if (Displaykkk.Data[j, i, 0] == 128 && Displaykkk.Data[j, i, 1] == 128 && Displaykkk.Data[j, i, 2] == 128)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 0)
                                        {
                                            if (P_pos[cc].X <= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].X <= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }

                                    }

                                }
                                if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 255)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Connect_Line_Serious_chb.Checked)
                                        {
                                            if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 0)
                                            {
                                                if (P_pos[cc].Y >= j)
                                                {
                                                    CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                    goto testout;
                                                }

                                            }
                                        }
                                        else
                                        {
                                            if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 0)
                                            {
                                                if (P_pos[cc].Y >= j)
                                                {
                                                    CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                    goto testout;
                                                }

                                            }
                                            if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 128)
                                            {
                                                if (P_pos[cc].Y >= j)
                                                {
                                                    CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                    goto testout;
                                                }
                                            }
                                            if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 0)
                                            {
                                                if (P_pos[cc].Y >= j)
                                                {

                                                    CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                    goto testout;
                                                }
                                            }
                                        }


                                    }
                                }
                                if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 0)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].Y <= j)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }

                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].Y <= j)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }

                                        }
                                    }
                                }
                                if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 0)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].Y <= j && P_pos[cc].X >= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }
                                    }

                                }
                                if (Displaykkk.Data[j, i, 0] == 128 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 128)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].Y >= j && P_pos[cc].X <= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }


                                        }
                                    }

                                }


                                testout:;
                            }

                        }
                    }
                }
                img = Displaykkk;
            }

        }
        private int AddOUT(int count)
        {
            int ini = 6;
            int total = 0;
            for (int i = 0; i < count; i++)
            {
                total = total + (ini + 8 * i);
            }
            return total;
        }

        private void button30_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                int max_radiun = (int)Distance_EdgeLInk.Value; ;
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Displaykkk = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                for (int i = max_radiun; i < Displaykkk.Width - max_radiun; i++)
                {
                    for (int j = max_radiun; j < Displaykkk.Height - max_radiun; j++)
                    {
                        if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 255)
                        {

                        }
                        else
                        {
                            if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 0)
                            {

                            }
                            else
                            {
                                int step = 0;
                                int x_step = i;
                                int y_step = j;
                                int x_min = i;
                                int y_min = j;
                                int x_max = i;
                                int y_max = j;
                                Point[] P_pos = new Point[AddOUT((int)Distance_EdgeLInk.Value) + 1];
                                do
                                {
                                    do//up
                                    {
                                        step++;
                                        y_step--;
                                        P_pos[step] = new Point(x_step, y_step);

                                    } while (y_step >= y_min);
                                    y_min = y_step;
                                    do//right
                                    {
                                        step++;
                                        x_step++;
                                        P_pos[step] = new Point(x_step, y_step);
                                    } while (x_step <= x_max);
                                    x_max = x_step;
                                    do//down
                                    {
                                        step++;
                                        y_step++;
                                        P_pos[step] = new Point(x_step, y_step);
                                    } while (y_step <= y_max);
                                    y_max = y_step;
                                    do//left
                                    {
                                        step++;
                                        x_step--;
                                        P_pos[step] = new Point(x_step, y_step);
                                    } while (x_step >= x_min);
                                    x_min = x_step;
                                } while (step < AddOUT((int)Distance_EdgeLInk.Value));
                                if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 0)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 128)
                                        {
                                            if (P_pos[cc].X >= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].X >= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }

                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 128)
                                        {
                                            if (P_pos[cc].X >= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }

                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 0)
                                        {
                                            {
                                                if (P_pos[cc].X >= i)
                                                {
                                                    CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                    goto testout;
                                                }
                                            }
                                        }
                                    }
                                }
                                if (Displaykkk.Data[j, i, 0] == 128 && Displaykkk.Data[j, i, 1] == 128 && Displaykkk.Data[j, i, 2] == 128)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 0)
                                        {
                                            if (P_pos[cc].X <= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].X <= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }

                                    }

                                }
                                if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 0 && Displaykkk.Data[j, i, 2] == 255)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 0)
                                        {
                                            if (P_pos[cc].Y >= j)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }

                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 128)
                                        {
                                            if (P_pos[cc].Y >= j)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 0)
                                        {
                                            if (P_pos[cc].Y >= j)
                                            {

                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }

                                    }
                                }
                                if (Displaykkk.Data[j, i, 0] == 0 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 0)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].Y <= j)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }

                                        }
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].Y <= j)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }

                                        }
                                    }
                                }
                                if (Displaykkk.Data[j, i, 0] == 255 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 0)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 128 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].Y <= j && P_pos[cc].X >= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }
                                        }
                                    }

                                }
                                if (Displaykkk.Data[j, i, 0] == 128 && Displaykkk.Data[j, i, 1] == 255 && Displaykkk.Data[j, i, 2] == 128)
                                {
                                    for (int cc = 1; cc < step; cc++)
                                    {
                                        if (Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 255 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 0 && Displaykkk.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                                        {
                                            if (P_pos[cc].Y >= j && P_pos[cc].X <= i)
                                            {
                                                CvInvoke.Line(Displaykkk, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                                                goto testout;
                                            }


                                        }
                                    }

                                }


                                testout:;
                            }

                        }
                    }
                }
                imageBox1.Image = Displaykkk;
            }
        }






        private void label18_Click(object sender, EventArgs e)
        {

        }


        private Image<Bgr, byte> Remove_path(int pos_X, int pos_Y, ref Image<Bgr, byte> img, int count)
        {
            int count_local = 0;
            Point point = new Point(0, 0);
            for (int a = -1; a < 2; a++)
            {
                for (int b = -1; b < 2; b++)
                {
                    if (img.Data[pos_Y + b, pos_X + a, 0] == 255 && img.Data[pos_Y + b, pos_X + a, 1] == 255 && img.Data[pos_Y + b, pos_X + a, 2] == 255)
                    {
                        if (a == 0 && b == 0)
                        { }
                        else
                        {
                            point.X = pos_X + a;
                            point.Y = pos_Y + b;

                            count_local = count_local + 1;

                        }

                    }

                }
            }
            if (count_local == 1)
            {
                img.Data[pos_Y, pos_X, 0] = 0;
                img.Data[pos_Y, pos_X, 1] = 0;
                img.Data[pos_Y, pos_X, 2] = 0;
                return Remove_path(point.X, point.Y, ref img, count + 1);
            }
            else
            {
                if (count_local == 2)
                {
                    img.Data[pos_Y, pos_X, 0] = 0;
                    img.Data[pos_Y, pos_X, 1] = 0;
                    img.Data[pos_Y, pos_X, 2] = 0;
                }
                return img;
            }

        }
        private int Count_step(int pos_X, int pos_Y, ref Image<Bgr, byte> img, int count)
        {
            int count_local = 0;
            Point point = new Point(0, 0);
            Image<Bgr, byte> CIR = new Image<Bgr, byte>(img.Bitmap);
            for (int a = -1; a < 2; a++)
            {
                for (int b = -1; b < 2; b++)
                {
                    if (img.Data[pos_Y + b, pos_X + a, 0] == 255 && img.Data[pos_Y + b, pos_X + a, 1] == 255 && img.Data[pos_Y + b, pos_X + a, 2] == 255)
                    {
                        if (a == 0 && b == 0)
                        {
                        }
                        else
                        {
                            point.X = pos_X + a;
                            point.Y = pos_Y + b;
                            count_local = count_local + 1;
                        }

                    }

                }
            }
            if (count_local == 1)
            {
                CIR.Data[pos_Y, pos_X, 0] = 0;
                CIR.Data[pos_Y, pos_X, 1] = 0;
                CIR.Data[pos_Y, pos_X, 2] = 0;
                return Count_step(point.X, point.Y, ref CIR, count + 1);
            }
            else
            {
                CIR.Data[pos_Y, pos_X, 0] = 0;
                CIR.Data[pos_Y, pos_X, 1] = 0;
                CIR.Data[pos_Y, pos_X, 2] = 0;
                return count;
            }

        }

        private Point Point_front(int pos_X, int pos_Y, Image<Bgr, byte> img, int count)
        {
            int count_local = 0;
            Point point = new Point(0, 0);
            Image<Bgr, byte> CIR = new Image<Bgr, byte>(img.Bitmap);
            for (int a = -1; a < 2; a++)
            {
                for (int b = -1; b < 2; b++)
                {
                    if (img.Data[pos_Y + b, pos_X + a, 0] == 255 && img.Data[pos_Y + b, pos_X + a, 1] == 255 && img.Data[pos_Y + b, pos_X + a, 2] == 255)
                    {
                        if (a == 0 && b == 0)
                        {
                        }
                        else
                        {
                            point.X = pos_X + a;
                            point.Y = pos_Y + b;
                            count_local = count_local + 1;
                        }

                    }

                }
            }
            if (count_local == 1)
            {
                CIR.Data[pos_Y, pos_X, 0] = 0;
                CIR.Data[pos_Y, pos_X, 1] = 0;
                CIR.Data[pos_Y, pos_X, 2] = 0;
                return Point_front(point.X, point.Y, CIR, count + 1);
            }
            else
            {
                CIR.Data[pos_Y, pos_X, 0] = 0;
                CIR.Data[pos_Y, pos_X, 1] = 0;
                CIR.Data[pos_Y, pos_X, 2] = 0;
                return new Point(pos_X, pos_Y);
            }

        }

        private void button29_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Image<Bgr, byte> Displaykkk = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                HistogramViewer.Show(Displaykkk[0], 32); //image[0] 顯示Blue,bin = 32
                HistogramViewer.Show(Displaykkk[1], 32); //image[0] 顯示Blue,bin = 32
                HistogramViewer.Show(Displaykkk[2], 32); //image[0] 顯示Blue,bin = 32
            }

        }

        private void button32_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Ori_Lines = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Ori_Lines_DISPLAY = new Image<Gray, byte>(1040, 1040);
                for (int i = 2; i < Ori_Lines.Width - 2; i = i + 1)
                {
                    for (int j = 2; j < Ori_Lines.Height - 2; j = j + 1)
                    {
                        int data = 0;
                        for (int w = -2; w < 3; w++)
                        {
                            for (int t = -2; t < 3; t++)
                            {

                                if (Ori_Lines.Data[j + t, i + w, 0] == 0 || Ori_Lines.Data[j, i, 0] == 0)
                                {

                                }
                                else
                                {
                                    data += ((int)(Math.Abs((int)(Ori_Lines.Data[j + t, i + w, 0] - Ori_Lines.Data[j, i, 0]))));
                                    if (data > 255)
                                        Ori_Lines_DISPLAY.Data[j, i, 0] = 255;
                                    else
                                        Ori_Lines_DISPLAY.Data[j, i, 0] = (byte)data;
                                    //Ori_Lines_DISPLAY.Data[j, i, 0] += ((Byte)(Math.Abs((int)(Ori_Lines.Data[j + t, i + w, 0] - Ori_Lines.Data[j, i, 0]))));
                                }

                            }
                        }
                        //if (Ori_Lines_DISPLAY.Data[j, i, 0] >100)
                        //{
                        //    Ori_Lines_DISPLAY.Data[j, i, 0] = 0;
                        //}

                        //Ori_Lines_DISPLAY.Data[j, i, 0] =((Byte)(Math.Abs((int)(Ori_Lines.Data[j - 1, i+1, 0] -Ori_Lines.Data[j , i, 0]))*2 + Math.Abs((int)(Ori_Lines.Data[j, i , 0] - Ori_Lines.Data[j, i , 0]))*2 + Math.Abs((int)(Ori_Lines.Data[j-1, i-1, 0] - Ori_Lines.Data[j, i, 0]))*2 + Math.Abs((int)(Ori_Lines.Data[j, i - 1, 0] - Ori_Lines.Data[j, i , 0]))*2 + Math.Abs((int)(Ori_Lines.Data[j, i + 1, 0] - Ori_Lines.Data[j, i, 0]))*2 + Math.Abs((int)(Ori_Lines.Data[j+1, i - 1, 0] - Ori_Lines.Data[j, i, 0]))*2 + Math.Abs((int)(Ori_Lines.Data[j+1, i , 0] - Ori_Lines.Data[j, i, 0]))*2 + Math.Abs((int)(Ori_Lines.Data[j+1, i + 1, 0] - Ori_Lines.Data[j, i, 0]))*2));

                    }
                }
                CannyMeddle = new Image<Gray, byte>(1040, 1040);
                CvInvoke.Threshold(Ori_Lines_DISPLAY, CannyMeddle, 0, 255, ThresholdType.Otsu);
                imageBox1.Image = Ori_Lines_DISPLAY;
            }
        }

        private void button33_Click(object sender, EventArgs e)
        {
            MessageBox.Show(AddOUT(4).ToString());
        }

        private void button9_Click(object sender, EventArgs e)
        {
            if (Save_Contour_image == null)
            {
            }
            else
            {
                imageBox1.Image = Save_Contour_image;
            }
        }

        private void button19_Click_1(object sender, EventArgs e)
        {
            if (Save_Contour_image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> CIR = new Image<Gray, byte>(Save_Contour_image.Bitmap);
                Image<Gray, byte> imgA = new Image<Gray, byte>(ori[1].ToBitmap());
                Image<Gray, byte> imgA_otsu = new Image<Gray, byte>(ori[1].ToBitmap());
                Image<Gray, byte> imgB_otsu = new Image<Gray, byte>(ori[1].ToBitmap());
                Image<Gray, byte> imgB = new Image<Gray, byte>(CIR.ToBitmap());
                Image<Gray, byte> img_Display = new Image<Gray, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
                Image<Bgr, byte> img_Displayggg = new Image<Bgr, byte>(ori.Bitmap);
                Image<Bgr, byte> img_DisplayBBB = new Image<Bgr, byte>(ori.Bitmap);
                Image<Bgr, byte> img_Real = new Image<Bgr, byte>(ori.Bitmap);
                Image<Gray, byte> CIR2 = new Image<Gray, byte>(1040, 1040);
                Image<Bgr, byte> imgC = new Image<Bgr, byte>(1040, 1040);
                CvInvoke.Circle(CIR2, new Point(Ori_x, Ori_y), (int)Circle_Filter.Value, new MCvScalar(255), -1);
                initialDatagrid();
                Mat hierarchy = new Mat();
                VectorOfVectorOfPoint contours_Finaaly = new VectorOfVectorOfPoint();  //找到的輪廓儲存
                CvInvoke.FindContours(imgB, contours_Finaaly, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 
                double[] AREA_B = new double[contours_Finaaly.Size];
                int count = 0;
                int total_mean = 0;
                double st_deviation = 0;
                int[] MCV_Global = new int[contours_Finaaly.Size + 1];
                double[] Position_x = new double[contours_Finaaly.Size + 1];
                double[] Position_y = new double[contours_Finaaly.Size + 1];
                double[] width = new double[contours_Finaaly.Size + 1];
                double[] height = new double[contours_Finaaly.Size + 1];
                for (int j = 0; j < contours_Finaaly.Size; j++)  //一個輪廓表示一個物體 //for對所有輪廓
                {
                    double Area = CvInvoke.ContourArea(contours_Finaaly[j]);
                    if (Area > (Double)Threshold_Area.Value)
                    {


                        MCvMoments[] mom = new MCvMoments[contours_Finaaly.Size]; //形心
                        int[] Cx = new int[contours_Finaaly.Size];  //x座標
                        int[] Cy = new int[contours_Finaaly.Size];  //y座標                
                        mom[j] = CvInvoke.Moments(contours_Finaaly[j]);
                        Cx[j] = (int)mom[j].GravityCenter.X;
                        Cy[j] = (int)mom[j].GravityCenter.Y;
                        Rectangle rect = CvInvoke.BoundingRectangle(contours_Finaaly[j]);
                        Point rcenter = new Point((int)rect.X, (int)rect.Y);
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_Finaaly[j]);

                        double A = (int)rotatedRect.Size.Width;
                        double B = (int)rotatedRect.Size.Height;
                        if (Math.Round(B / A, 1) < (double)W_HRate_defect.Value && Area / (A * B * Math.PI) > (double)RoundShape.Value / 100)
                        {
                            Position_x[count] = (double)rect.X;
                            Position_y[count] = (double)rect.Y;
                            width[count] = (double)rect.Width;
                            height[count] = (double)rect.Height;
                            count++;
                            CvInvoke.DrawContours(img_Display, contours_Finaaly, j, new MCvScalar(255, 255, 255), -1);
                            //CvInvoke.PutText(imgA, OtsuImg(temp,128,10).ToString(), new System.Drawing.Point(Cx[j], Cy[j]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 2);
                        }
                    }

                }
                imgA = imgA.And(img_Display);

                for (int c = 0; c < count; c++)
                {
                    Image<Gray, byte> temp = new Image<Gray, byte>((int)width[c], (int)height[c]);
                    Image<Gray, byte> temp_dst = new Image<Gray, byte>((int)width[c], (int)height[c]);
                    for (int i = 0; i < width[c] - 1; i++)
                    {
                        for (int j = 0; j < height[c] - 1; j++)
                        {
                            if (imgA.Data[(int)Position_y[c] + j, (int)Position_x[c] + i, 0] == 0)
                            {

                            }
                            else
                            {
                                temp.Data[j, i, 0] = imgA.Data[(int)Position_y[c] + j, (int)Position_x[c] + i, 0];
                            }
                        }
                    }
                    //MCvScalar MCV = CvInvoke.Mean(temp);
                    MCV_Global[c] = (int)ImgMean(temp);
                    //ImgMean_Img(temp).Save("C:/Users/K501/Desktop/1/" + c.ToString() + ".jpg");
                    //if (c == 1)
                    //    imageBox1.Image = ImgMean_Img(temp);

                    total_mean = total_mean + MCV_Global[c];
                    //CvInvoke.PutText(img_Displayggg, MCV_Global[c].ToString(), new System.Drawing.Point((int)Position_x[c], (int)Position_y[c]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 2);

                }
                averange_display.Text = ((int)(total_mean / count)).ToString();

                for (int c = 0; c < count; c++)
                {
                    st_deviation = st_deviation + Math.Sqrt(Math.Pow(MCV_Global[c] - (total_mean / count), 2) / count);
                }
                st_display.Text = ((int)st_deviation).ToString();
                for (int c = 0; c < count; c++)
                {
                    Image<Gray, byte> temp = new Image<Gray, byte>((int)width[c], (int)height[c]);
                    Image<Gray, byte> temp_dst = new Image<Gray, byte>((int)width[c], (int)height[c]);
                    Image<Gray, byte> temp_dst_otsu = new Image<Gray, byte>((int)width[c], (int)height[c]);
                    int Size_image = (int)width[c] * (int)height[c];
                    int Whitepoint = 0;


                    for (int i = 0; i < width[c] - 1; i++)
                    {
                        for (int j = 0; j < height[c] - 1; j++)
                        {
                            if (imgA.Data[(int)Position_y[c] + j, (int)Position_x[c] + i, 0] == 0)
                            {

                            }
                            else
                            {
                                if (MCV_Global[c] > (total_mean / count) - (double)standard_diff.Value * st_deviation)
                                {
                                    temp.Data[j, i, 0] = imgA.Data[(int)Position_y[c] + j, (int)Position_x[c] + i, 0];

                                }
                                else
                                {
                                    temp.Data[j, i, 0] = 0;
                                }

                            }
                        }
                    }
                    if (MCV_Global[c] > (total_mean / count) - (double)standard_diff.Value * st_deviation)
                    {

                        CvInvoke.Threshold(temp, temp_dst_otsu, ImgMean(temp), 255, ThresholdType.Binary);
                        CvInvoke.Threshold(temp, temp_dst, 0, 255, ThresholdType.Binary);


                        //MessageBox.Show(MCV.V0.ToString());
                        for (int w = 0; w < width[c] - 1; w++)
                        {
                            for (int k = 0; k < height[c] - 1; k++)
                            {
                                if (temp_dst.Data[k, w, 0] == 0)
                                {
                                    imgA_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = 0;
                                    imgB_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = 0;
                                }
                                else
                                {
                                    imgA_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = temp_dst.Data[k, w, 0];
                                    imgB_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = temp_dst_otsu.Data[k, w, 0];
                                }

                            }
                        }
                    }
                    else
                    {
                        for (int w = 0; w < width[c] - 1; w++)
                        {
                            for (int k = 0; k < height[c] - 1; k++)
                            {
                                imgA_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = 0;
                                imgB_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = 0;
                            }
                        }
                    }



                }

                int Count = 0;
                int Count2 = 0;
                int Count3 = 0;
                CvInvoke.Threshold(imgA_otsu.And(img_Display), imgA_otsu, 0, 255, ThresholdType.Binary);
                CvInvoke.Threshold(imgB_otsu.And(img_Display), imgB_otsu, 0, 255, ThresholdType.Binary);


                VectorOfVectorOfPoint contours_kk = new VectorOfVectorOfPoint();  //找到的輪廓儲存
                VectorOfVectorOfPoint contours_kkB = new VectorOfVectorOfPoint();  //找到的輪廓儲存
                imgA_otsu = imgA_otsu.Sub(CIR2).Erode(1).Dilate(1);
                imgB_otsu = imgB_otsu.Sub(CIR2).Erode(1).Dilate(1);
                CvInvoke.FindContours(imgA_otsu, contours_kk, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 
                CvInvoke.FindContours(imgB_otsu, contours_kkB, hierarchy, RetrType.Tree, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 

                for (int j = 0; j < contours_kk.Size; j++)  //一個輪廓表示一個物體 //for對所有輪廓
                {
                    double Area2 = CvInvoke.ContourArea(contours_kk[j]);
                    if (Area2 > (Double)Threshold_Area.Value)
                    {
                        //RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_kk[j]);
                        MCvMoments[] mom = new MCvMoments[contours_kk.Size]; //形心
                        int[] Cx = new int[contours_kk.Size];  //x座標
                        int[] Cy = new int[contours_kk.Size];  //y座標                
                        mom[j] = CvInvoke.Moments(contours_kk[j]);
                        Cx[j] = (int)mom[j].GravityCenter.X;
                        Cy[j] = (int)mom[j].GravityCenter.Y;
                        Rectangle rect = CvInvoke.BoundingRectangle(contours_kk[j]);
                        Point rcenter = new Point((int)rect.X, (int)rect.Y);
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_kk[j]);

                        double A = (int)rotatedRect.Size.Width;
                        double B = (int)rotatedRect.Size.Height;
                        //double A = (int)rotatedRect.Size.Width;
                        //double B = (int)rotatedRect.Size.Height;

                        if (Math.Round(Area2 / (B * A * Math.PI) * 4, 3) > (double)Area_rate.Value && Math.Round(B / A, 1) < (double)W_HRate_defect.Value)
                        {
                            CvInvoke.DrawContours(img_Displayggg, contours_kk, j, new MCvScalar(0, 255, 255), 1);
                            CvInvoke.DrawContours(img_Real, contours_kk, j, new MCvScalar(0, 255, 255), 1);
                            CvInvoke.DrawContours(imgC, contours_kk, j, new MCvScalar(255, 255, 255), -1);

                            for (int x = 0; x < contours_kk[j].Size; x = x + 15)
                            {
                                CvInvoke.Circle(img_Displayggg, new Point(contours_kk[j][x].X, contours_kk[j][x].Y), (int)RoundShape.Value, new MCvScalar(255, 255, 255), -1);
                                CvInvoke.Circle(img_Real, new Point(contours_kk[j][x].X, contours_kk[j][x].Y), (int)RoundShape.Value, new MCvScalar(255, 255, 255), -1);
                            }

                            //CvInvoke.Circle(img_Displayggg, new System.Drawing.Point(Cx[j], Cy[j]), 5, new MCvScalar(0, 0, 255), -1);
                            dataGridView1.Rows.Add((Count + 1).ToString(), ((int)Area2).ToString(), Math.Round(B / A, 1).ToString(), Math.Round((int)Area2 / (B * A * Math.PI) * 4, 2).ToString(), MCV_Global[Count2].ToString());
                            //for (int x = 0; x < contours_kk[j].Size; x = x + 15)
                            //{
                            //    CvInvoke.Circle(img_Displayggg, new Point(contours_kk[j][x].X, contours_kk[j][x].Y), 10, new MCvScalar(255, 255, 255), -1);
                            //}
                            if (number_visible.Checked)
                                CvInvoke.PutText(img_Displayggg, (Count + 1).ToString(), new System.Drawing.Point(Cx[j], Cy[j]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(0, 0, 255), 2);
                            Count++;

                        }

                    }
                    Count2++;
                }
                for (int j = 0; j < contours_kkB.Size; j++)  //一個輪廓表示一個物體 //for對所有輪廓
                {
                    double Area2 = CvInvoke.ContourArea(contours_kkB[j]);
                    if (Area2 > (Double)Threshold_Area.Value)
                    {
                        //RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_kk[j]);
                        MCvMoments[] mom = new MCvMoments[contours_kkB.Size]; //形心
                        int[] Cx = new int[contours_kkB.Size];  //x座標
                        int[] Cy = new int[contours_kkB.Size];  //y座標                
                        mom[j] = CvInvoke.Moments(contours_kkB[j]);
                        Cx[j] = (int)mom[j].GravityCenter.X;
                        Cy[j] = (int)mom[j].GravityCenter.Y;
                        Rectangle rect = CvInvoke.BoundingRectangle(contours_kkB[j]);
                        Point rcenter = new Point((int)rect.X, (int)rect.Y);
                        RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_kkB[j]);

                        double A = (int)rotatedRect.Size.Width;
                        double B = (int)rotatedRect.Size.Height;
                        //double A = (int)rotatedRect.Size.Width;
                        //double B = (int)rotatedRect.Size.Height;

                        if (Math.Round(Area2 / (B * A * Math.PI) * 4, 3) > (double)Area_rate.Value && Math.Round(B / A, 1) < (double)W_HRate_defect.Value)
                        {
                            CvInvoke.DrawContours(img_DisplayBBB, contours_kkB, j, new MCvScalar(0, 255, 255), 1);

                            if (number_visible.Checked)
                                CvInvoke.PutText(img_DisplayBBB, (Count3 + 1).ToString(), new System.Drawing.Point(Cx[j], Cy[j]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(0, 0, 255), 2);
                            Count3++;

                        }

                    }
                }
                Save_Contour_image = imgC;
                LockImage = new Image<Bgr, byte>(img_Real.Bitmap);
                imageBox1.Image = img_Displayggg;
                imageBox_otsu.Image = img_DisplayBBB;
                //CvInvoke.FloodFill(img_Display, img_Displayggg, seed, new MCvScalar(255,255,255), out RR, new MCvScalar(0, 0,0),new MCvScalar(255, 255, 255));
                //button13_Click_1( sender,  e);

            }
            //if (Math.Round(Area2 / (B * A * Math.PI) * 4, 3) > (double)Area_rate.Value && Math.Round(B / A, 1) < (double)W_HRate_defect.Value)
            //{

            //    CvInvoke.DrawContours(img_Displayggg, contours_kk, j, new MCvScalar(0, 255, 255), 1);
            //    CvInvoke.DrawContours(img_Real, contours_kk, j, new MCvScalar(0, 255, 255), 1);
            //    CvInvoke.DrawContours(imgC, contours_kk, j, new MCvScalar(255, 255, 255), -1);

            //    for (int x = 0; x < contours_kk[j].Size; x = x + 15)
            //    {
            //        CvInvoke.Circle(img_Displayggg, new Point(contours_kk[j][x].X, contours_kk[j][x].Y), (int)RoundShape.Value, new MCvScalar(255, 255, 255), -1);
            //        CvInvoke.Circle(img_Real, new Point(contours_kk[j][x].X, contours_kk[j][x].Y), (int)RoundShape.Value, new MCvScalar(255, 255, 255), -1);
            //    }

            //    //CvInvoke.Circle(img_Displayggg, new System.Drawing.Point(Cx[j], Cy[j]), 5, new MCvScalar(0, 0, 255), -1);
            //    dataGridView1.Rows.Add((Count + 1).ToString(), ((int)Area2).ToString(), Math.Round(B / A, 1).ToString(), Math.Round((int)Area2 / (B * A * Math.PI) * 4, 2).ToString(), MCV_Global[Count2].ToString());
            //    //for (int x = 0; x < contours_kk[j].Size; x = x + 15)
            //    //{
            //    //    CvInvoke.Circle(img_Displayggg, new Point(contours_kk[j][x].X, contours_kk[j][x].Y), 10, new MCvScalar(255, 255, 255), -1);
            //    //}
            //    if (number_visible.Checked)
            //        CvInvoke.PutText(img_Displayggg, (Count + 1).ToString(), new System.Drawing.Point(Cx[j], Cy[j]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(0, 0, 255), 2);
            //    Count++;

            //}
            //else
            //{

            //}
            //if (MCV_Global[c] > (total_mean / count) - (double)standard_diff.Value * st_deviation)
            //{
            //    CvInvoke.Threshold(temp, temp_dst, OtsuImg(temp, MCV_Global[c] - (int)Otsu_Second.Value, 35), 255, ThresholdType.Binary);
            //    //MessageBox.Show(MCV.V0.ToString());
            //    for (int w = 0; w < width[c] - 1; w++)
            //    {
            //        for (int k = 0; k < height[c] - 1; k++)
            //        {
            //            if (temp_dst.Data[k, w, 0] == 0)
            //                imgA_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = 0;
            //            else
            //                imgA_otsu.Data[(int)Position_y[c] + k, (int)Position_x[c] + w, 0] = temp_dst.Data[k, w, 0];
            //        }
            //    }
            //}
            //else
            //{

            //}
        }

        private void chb_otsu_CheckedChanged(object sender, EventArgs e)
        {
            if (chb_otsu.Checked)
            {
                imageBox1.Visible = false;
                imageBox_otsu.Visible = true;
            }
            else
            {
                imageBox_otsu.Visible = false;
                imageBox1.Visible = true;
            }
        }

        private void button20_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                imageBox1.Image = Display222.Sub(CannyMeddle);

            }
        }

        private void button2_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> DisplayX_dir = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> DisplayBGR = new Image<Bgr, byte>(ori.SmoothMedian(11).Bitmap);
                Image<Bgr, byte> DisplayBGR_test = new Image<Bgr, byte>(DisplayX_dir.SmoothMedian(11).Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(1040, 1040);
                if (Connect_Line_Serious_chb2.Checked)
                    Display222 = new Image<Gray, byte>(DisplayBGR_test[1].Bitmap);
                else
                    Display222 = new Image<Gray, byte>(DisplayBGR[1].Bitmap);

                Image<Gray, byte> Gradient_test = new Image<Gray, byte>(1040, 1040);
                for (int i = 2; i < Display222.Width - 2; i = i + 1)
                {
                    for (int j = 2; j < Display222.Height - 2; j = j + 1)//對整張圖去做檢視
                    {
                        int data = 0;

                        for (int t = -1; t < 2; t++)//做5X5梯度變化的灰階疊加
                        {
                            if (Display222.Data[j + t, i, 0] == 0 || Display222.Data[j, i, 0] == 0 || Display222.Data[j + t, i + 1, 0] == 0 || Display222.Data[j + t, i - 1, 0] == 0)//條件為判斷梯度的像素灰階不能為0
                            {

                            }
                            else
                            {

                                if (t == 0)
                                {
                                    data += (int)Rate_Filter.Value * 2 * ((int)(Math.Abs((int)(Display222.Data[j + t, i + 1, 0] - Display222.Data[j + t, i - 1, 0]))));
                                    if (data > 255)
                                        Gradient_test.Data[j, i, 0] = 255;
                                    else
                                        Gradient_test.Data[j, i, 0] = (byte)data;
                                }
                                else
                                {
                                    data += (int)Rate_Filter.Value * ((int)(Math.Abs((int)(Display222.Data[j + t, i + 1, 0] - Display222.Data[j + t, i - 1, 0]))));
                                    if (data > 255)
                                        Gradient_test.Data[j, i, 0] = 255;
                                    else
                                        Gradient_test.Data[j, i, 0] = (byte)data;

                                }

                                //Gradient_test.Data[j, i, 0] += ((Byte)(Math.Abs((int)(oriii.Data[j + t, i + w, 0] - oriii.Data[j, i, 0]))));//取原灰階G層做梯度變化圖，為了要使用Edge Link

                            }

                        }

                    }
                }
                if (Connect_Line_Serious_chb.Checked)
                    imageBox1.Image = Gradient_test.Or(DisplayX_dir);
                else
                    imageBox1.Image = Gradient_test;
            }
        }

        private void button3_Click_1(object sender, EventArgs e)
        {

            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> DisplayBGR = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(DisplayBGR[1].Bitmap);

                imageBox1.Image = Display222.SmoothMedian(11);
            }
        }

        private void button6_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> DisplayX_dir = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> DisplayBGR = new Image<Bgr, byte>(ori.SmoothMedian(11).Bitmap);
                Image<Bgr, byte> DisplayBGR_test = new Image<Bgr, byte>(DisplayX_dir.SmoothMedian(11).Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(1040, 1040);
                if (Connect_Line_Serious_chb2.Checked)
                    Display222 = new Image<Gray, byte>(DisplayBGR_test[1].Bitmap);
                else
                    Display222 = new Image<Gray, byte>(DisplayBGR[1].Bitmap);

                Image<Gray, byte> Gradient_test = new Image<Gray, byte>(1040, 1040);
                for (int i = 2; i < Display222.Width - 2; i = i + 1)
                {
                    for (int j = 2; j < Display222.Height - 2; j = j + 1)//對整張圖去做檢視
                    {
                        int data = 0;

                        for (int t = -1; t < 2; t++)//做5X5梯度變化的灰階疊加
                        {
                            if (Display222.Data[j, i + t, 0] == 0 || Display222.Data[j, i, 0] == 0 || Display222.Data[j + 1, i + t, 0] == 0 || Display222.Data[j - 1, i + t, 0] == 0)//條件為判斷梯度的像素灰階不能為0
                            {

                            }
                            else
                            {
                                if (t == 0)
                                {
                                    data += (int)Rate_Filter.Value * 2 * ((int)(Math.Abs((int)(Display222.Data[j + 1, i + t, 0] - Display222.Data[j - 1, i + t, 0]))));
                                    if (data > 255)
                                        Gradient_test.Data[j, i, 0] = 255;
                                    else
                                        Gradient_test.Data[j, i, 0] = (byte)data;
                                }
                                else
                                {
                                    data += (int)Rate_Filter.Value * ((int)(Math.Abs((int)(Display222.Data[j + 1, i + t, 0] - Display222.Data[j - 1, i + t, 0]))));
                                    if (data > 255)
                                        Gradient_test.Data[j, i, 0] = 255;
                                    else
                                        Gradient_test.Data[j, i, 0] = (byte)data;
                                }

                                //Gradient_test.Data[j, i, 0] += ((Byte)(Math.Abs((int)(oriii.Data[j + t, i + w, 0] - oriii.Data[j, i, 0]))));//取原灰階G層做梯度變化圖，為了要使用Edge Link

                            }

                        }

                    }
                }
                imageBox1.Image = Gradient_test;
            }
        }

        private void button4_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> DisplayX_dir = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> DisplayBGR = new Image<Bgr, byte>(ori.SmoothMedian(11).Bitmap);
                Image<Bgr, byte> DisplayBGR_test = new Image<Bgr, byte>(DisplayX_dir.SmoothMedian(11).Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(1040, 1040);
                if (Connect_Line_Serious_chb2.Checked)
                    Display222 = new Image<Gray, byte>(DisplayBGR_test[1].Bitmap);
                else
                    Display222 = new Image<Gray, byte>(DisplayBGR[1].Bitmap);

                Image<Gray, byte> Gradient_test = new Image<Gray, byte>(1040, 1040);

                for (int i = 2; i < Display222.Width - 2; i = i + 1)
                {
                    for (int j = 2; j < Display222.Height - 2; j = j + 1)//對整張圖去做檢視
                    {
                        int data = 0;

                        for (int t = -1; t < 2; t++)//做5X5梯度變化的灰階疊加
                        {
                            if (Display222.Data[j, i + t, 0] == 0 || Display222.Data[j, i, 0] == 0 || Display222.Data[j + 1, i + t, 0] == 0 || Display222.Data[j - 1, i + t, 0] == 0)//條件為判斷梯度的像素灰階不能為0
                            {

                            }
                            else
                            {
                                if (t == 0)
                                {
                                    data += (int)Rate_Filter.Value * 10 * ((int)(Math.Abs((int)(Display222.Data[j + 1, i + t, 0] - Display222.Data[j - 1, i + t, 0]))));
                                    if (data > 255)
                                        Gradient_test.Data[j, i, 0] = 255;
                                    else
                                        Gradient_test.Data[j, i, 0] = (byte)data;
                                }
                                else
                                {
                                    data += (int)Rate_Filter.Value * 3 * ((int)(Math.Abs((int)(Display222.Data[j + 1, i + t, 0] - Display222.Data[j - 1, i + t, 0]))));
                                    if (data > 255)
                                        Gradient_test.Data[j, i, 0] = 255;
                                    else
                                        Gradient_test.Data[j, i, 0] = (byte)data;
                                }

                                //Gradient_test.Data[j, i, 0] += ((Byte)(Math.Abs((int)(oriii.Data[j + t, i + w, 0] - oriii.Data[j, i, 0]))));//取原灰階G層做梯度變化圖，為了要使用Edge Link

                            }

                        }

                    }
                }
                imageBox1.Image = Gradient_test;
            }
        }

        private void button10_Click_2(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> DisplayX_dir = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> DisplayBGR = new Image<Bgr, byte>(ori.SmoothMedian(11).Bitmap);
                Image<Bgr, byte> DisplayBGR_test = new Image<Bgr, byte>(DisplayX_dir.SmoothMedian(11).Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(1040, 1040);
                if (Connect_Line_Serious_chb2.Checked)
                    Display222 = new Image<Gray, byte>(DisplayBGR_test[1].Bitmap);
                else
                    Display222 = new Image<Gray, byte>(DisplayBGR[1].Bitmap);

                Image<Gray, byte> Gradient_test = new Image<Gray, byte>(1040, 1040);

                for (int i = 2; i < Display222.Width - 2; i = i + 1)
                {
                    for (int j = 2; j < Display222.Height - 2; j = j + 1)//對整張圖去做檢視
                    {
                        int data = 0;

                        for (int t = -1; t < 2; t++)//做5X5梯度變化的灰階疊加
                        {
                            if (Display222.Data[j + t, i, 0] == 0 || Display222.Data[j, i, 0] == 0 || Display222.Data[j + t, i + 1, 0] == 0 || Display222.Data[j + t, i - 1, 0] == 0)//條件為判斷梯度的像素灰階不能為0
                            {

                            }
                            else
                            {

                                if (t == 0)
                                {
                                    data += 10 * ((int)(Math.Abs((int)(Display222.Data[j + t, i + 1, 0] - Display222.Data[j + t, i - 1, 0]))));
                                    if (data > 255)
                                        Gradient_test.Data[j, i, 0] = 255;
                                    else
                                        Gradient_test.Data[j, i, 0] = (byte)data;
                                }
                                else
                                {
                                    data += 3 * ((int)(Math.Abs((int)(Display222.Data[j + t, i + 1, 0] - Display222.Data[j + t, i - 1, 0]))));
                                    if (data > 255)
                                        Gradient_test.Data[j, i, 0] = 255;
                                    else
                                        Gradient_test.Data[j, i, 0] = (byte)data;

                                }

                                //Gradient_test.Data[j, i, 0] += ((Byte)(Math.Abs((int)(oriii.Data[j + t, i + w, 0] - oriii.Data[j, i, 0]))));//取原灰階G層做梯度變化圖，為了要使用Edge Link

                            }

                        }

                    }
                }
                if (Connect_Line_Serious_chb.Checked)
                    imageBox1.Image = Gradient_test.Or(DisplayX_dir);
                else
                    imageBox1.Image = Gradient_test;
            }
        }

        private void button5_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Gradient_test = new Image<Gray, byte>(imageBox1.Image.Bitmap);

                MCvScalar MCV2 = CvInvoke.Mean(Gradient_test);
                CvInvoke.Threshold(Gradient_test, Gradient_test, OtsuImg(Gradient_test, (int)MCV2.V0 + 15, 35), 255, ThresholdType.Binary);
                imageBox1.Image = Gradient_test;
            }
        }

        private void button11_Click_2(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Gradient_test = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Ori_Image = new Image<Bgr, byte>(ori.Bitmap);
                imageBox1.Image = Ori_Image.And(Gradient_test);
            }
        }

        private void button12_Click_2(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> DisplayX_dir = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> DisplayBGR = new Image<Bgr, byte>(ori.SmoothMedian(11).Bitmap);
                Image<Bgr, byte> DisplayBGR_test = new Image<Bgr, byte>(DisplayX_dir.SmoothMedian(11).Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(1040, 1040);
                if (Connect_Line_Serious_chb2.Checked)
                    Display222 = new Image<Gray, byte>(DisplayBGR_test[1].Bitmap);
                else
                    Display222 = new Image<Gray, byte>(DisplayBGR[1].Bitmap);

                Image<Gray, byte> Gradient_test = new Image<Gray, byte>(1040, 1040);

                for (int i = 2; i < Display222.Width - 2; i = i + 1)
                {
                    for (int j = 2; j < Display222.Height - 2; j = j + 1)//對整張圖去做檢視
                    {
                        int data = 0;
                        int count = 0;

                        for (int t = -1; t < 2; t++)//做5X5梯度變化的灰階疊加
                        {
                            for (int w = -1; w < 2; w++)//做5X5梯度變化的灰階疊加
                            {
                                count++;
                                if (count % 2 == 0)
                                {
                                    if (Display222.Data[j + w, i + t, 0] == 0 || Display222.Data[j, i, 0] == 0)//條件為判斷梯度的像素灰階不能為0
                                    {

                                    }
                                    else
                                    {
                                        {

                                            data += (int)Rate_Filter.Value * ((int)(Math.Abs((int)(Display222.Data[j, i, 0] - Display222.Data[j + w, i + t, 0]))));
                                            if (data > 255)
                                                Gradient_test.Data[j, i, 0] = 255;
                                            else
                                                Gradient_test.Data[j, i, 0] = (byte)data;

                                        }

                                        //Gradient_test.Data[j, i, 0] += ((Byte)(Math.Abs((int)(oriii.Data[j + t, i + w, 0] - oriii.Data[j, i, 0]))));//取原灰階G層做梯度變化圖，為了要使用Edge Link

                                    }
                                }
                                else
                                {
                                }


                            }
                        }

                    }
                }
                imageBox1.Image = Gradient_test;
            }
        }

        private void button14_Click_2(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> DisplayX_dir = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> DisplayBGR = new Image<Bgr, byte>(ori.SmoothMedian(11).Bitmap);
                Image<Bgr, byte> DisplayBGR_test = new Image<Bgr, byte>(DisplayX_dir.SmoothMedian(11).Bitmap);
                Image<Gray, byte> Display222 = new Image<Gray, byte>(1040, 1040);
                if (Combinecc.Checked)
                    Display222 = new Image<Gray, byte>(DisplayBGR_test[1].Bitmap);
                else
                    Display222 = new Image<Gray, byte>(DisplayBGR[1].Bitmap);

                Image<Gray, byte> Gradient_test = new Image<Gray, byte>(1040, 1040);

                for (int i = 2; i < Display222.Width - 2; i = i + 1)
                {
                    for (int j = 2; j < Display222.Height - 2; j = j + 1)//對整張圖去做檢視
                    {
                        int data = 0;

                        for (int t = -2; t < 3; t++)//做5X5梯度變化的灰階疊加
                        {
                            for (int w = -2; w < 3; w++)//做5X5梯度變化的灰階疊加
                            {

                                if (Display222.Data[j + w, i + t, 0] == 0 || Display222.Data[j, i, 0] == 0)//條件為判斷梯度的像素灰階不能為0
                                {

                                }
                                else
                                {
                                    {

                                        data += (int)Rate_Filter.Value * ((int)(Math.Abs((int)(Display222.Data[j, i, 0] - Display222.Data[j + w, i + t, 0]))));
                                        if (data > 255)
                                            Gradient_test.Data[j, i, 0] = 255;
                                        else
                                            Gradient_test.Data[j, i, 0] = (byte)data;

                                    }

                                    //Gradient_test.Data[j, i, 0] += ((Byte)(Math.Abs((int)(oriii.Data[j + t, i + w, 0] - oriii.Data[j, i, 0]))));//取原灰階G層做梯度變化圖，為了要使用Edge Link

                                }




                            }
                        }

                    }
                }
                imageBox1.Image = Gradient_test;
            }
        }

        private void button15_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> DisplayX_dir = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                imageBox1.Image = DisplayX_dir.Dilate(1);
            }
        }

        private void button16_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> DisplayX_dir = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                imageBox1.Image = DisplayX_dir.Erode(1);
            }
        }

        private void button17_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> DisplayX_dir = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                var dsttest = new Mat();
                XImgprocInvoke.Thinning(DisplayX_dir, dsttest, ThinningTypes.GuoHall);
                imageBox1.Image = dsttest;
            }

        }

        private void button18_Click_2(object sender, EventArgs e)
        {

            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                //ColorPint(ref Connect_img);

                ConnectedLine(ref Connect_img);
                imageBox1.Image = Connect_img;
            }


        }

        private void button20_Click_2(object sender, EventArgs e)
        {

            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Connect_img_gray = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                gray = Connect_img_gray;
                Image<Gray, byte> G1 = new Image<Gray, byte>(gray.Width, gray.Height);
                Image<Gray, byte> G2 = new Image<Gray, byte>(gray.Width, gray.Height);
                Image<Gray, byte> G3 = new Image<Gray, byte>(gray.Width, gray.Height);

                //int m = 0;//x
                //int b = 0;//y
                //bool A = false;

                //for (int y = 0; y < gray.Height; y++)
                //{
                //    for (int x = gray.Width - 1; x >= 0; x--)
                //    {
                //        if (gray.Data[y, x, 0] == 255)
                //        {
                //            m = x;
                //            b = y;
                //        }
                //    }
                //}
                //Debug.Print(" 起始 : " + " y : " + b.ToString() + " x : " + m.ToString());

                int m = 0;
                int b = 0;
                bool A = false;

                for (int y = 0; y < gray.Height; y++)
                {
                    for (int x = 0; x < gray.Width; x++)
                    {
                        if (gray.Data[y, x, 0] == 255)
                        {
                            m = x;
                            b = y;
                            A = true;
                            break;
                        }
                    }
                    if (A == true)
                    {
                        break;
                    }
                }
                Debug.Print(" 起始 : " + " y : " + b.ToString() + " x : " + m.ToString());

                //---------------------------------------------
                /*左下角起始點 逆時針版本
                //int[] xx = new int[18] { -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1,-1 };
                //int[] yy = new int[18] { -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1 ,0};
                 * */
                //左上角起始點 順時針版本
                int[] xx = new int[18] { -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0 };
                int[] yy = new int[18] { -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1 };

                G1.Data[b, m, 0] = 255;  //第一個點
                Debug.Print("起始點 : " + " y : " + b.ToString() + " x : " + m.ToString());

                int ny = b, nx = m;  //new y; new x;
                int i = 0;
                int u = 2;
                bool start = false;

                int[,] EdgePoint = new int[2, 5000];//儲存邊緣點座標
                int[] Eight_ChainCode = new int[5000];
                int EdgePointNumber = 0;//邊緣點數量

                int EdgePointN = 0;
                EdgePoint[0, EdgePointNumber] = nx;
                EdgePoint[1, EdgePointNumber] = ny;

                while ((ny != b || nx != m) || (start == false))
                {
                    start = true;
                    for (i = u; i < u + 16; i++) //
                    {
                        if (i < 0)
                            i = 0;
                        if (ny + yy[i] >= 0 && nx + xx[i] >= 0)
                        {
                            if (gray.Data[ny + yy[i], nx + xx[i], 0] == 255)
                            {
                                G1.Data[ny + yy[i], nx + xx[i], 0] = 255;
                                Debug.Print(" y : " + (ny + yy[i]).ToString() + " x : " + (nx + xx[i]).ToString());
                                //Debug.Print(" y : " + (ny + yy[i]).ToString() + " x : " + (nx + xx[i]).ToString());
                                EdgePoint[0, EdgePointNumber + 1] = nx + xx[i];
                                EdgePoint[1, EdgePointNumber + 1] = ny + yy[i];
                                ny = ny + yy[i];
                                nx = nx + xx[i];
                                if (i == 0 || i == 8 || i == 16)
                                {
                                    Eight_ChainCode[EdgePointN] = 8;//紀錄八方鍊碼方位
                                }
                                if (i == 1 || i == 9)
                                {
                                    Eight_ChainCode[EdgePointN] = 7;//紀錄八方鍊碼方位
                                }
                                if (i == 2 || i == 10)
                                {
                                    Eight_ChainCode[EdgePointN] = 6;//紀錄八方鍊碼方位
                                }
                                if (i == 3 || i == 11)
                                {
                                    Eight_ChainCode[EdgePointN] = 5;//紀錄八方鍊碼方位
                                }
                                if (i == 4 || i == 12)
                                {
                                    Eight_ChainCode[EdgePointN] = 4;//紀錄八方鍊碼方位
                                }
                                if (i == 5 || i == 13)
                                {
                                    Eight_ChainCode[EdgePointN] = 3;//紀錄八方鍊碼方位
                                }
                                if (i == 6 || i == 14)
                                {
                                    Eight_ChainCode[EdgePointN] = 2;//紀錄八方鍊碼方位
                                }
                                if (i == 7 || i == 15)
                                {
                                    Eight_ChainCode[EdgePointN] = 1;//紀錄八方鍊碼方位
                                }
                                i = i - 2;
                                u = i;
                                EdgePointN++;
                                EdgePointNumber++;
                                break;
                            }
                        }
                    }
                }
                double[] ContoursLength = new double[1];
                VectorOfVectorOfPoint contours = new VectorOfVectorOfPoint();
                CvInvoke.FindContours(gray, contours, null, RetrType.External, ChainApproxMethod.ChainApproxNone);
                for (int h = 0; h < 1; h++)
                {
                    CvInvoke.DrawContours(G2, contours, h, new MCvScalar(255), -1);
                    ContoursLength[h] = CvInvoke.ArcLength(contours[h], false);
                }
                double len = ContoursLength[0];//
                Debug.Print("len: " + len.ToString());
                Debug.Print("EdgePointN" + EdgePointN.ToString());
                Debug.Print("EdgePointNumber" + EdgePointNumber.ToString());
                imageBox_otsu.Image = G1;
                int Order = (int)Order1.Value;
                //VectorOfVectorOfPoint contours = new VectorOfVectorOfPoint();
                //CvInvoke.FindContours(G1,contours,null, RetrType.External, ChainApproxMethod.ChainApproxNone);
                //double len=CvInvoke.ArcLength(contours, false);
                //Debug.Print("len":+len.ToString());
                //橢圓傅立葉描述子
                double[] DeltaTi = new double[EdgePointNumber];
                double[] DeltaXi = new double[EdgePointNumber];
                double[] DeltaYi = new double[EdgePointNumber];
                double[] TotalTime = new double[EdgePointNumber + 1];
                double[] Fourier_A = new double[Order + 1];
                double[] Fourier_B = new double[Order + 1];
                double[] Fourier_C = new double[Order + 1];
                double[] Fourier_D = new double[Order + 1];

                double[] XX = new double[EdgePointNumber];
                double[] YY = new double[EdgePointNumber];

                Image<Gray, byte> FD_Image = new Image<Gray, byte>(1100, 1100, new Gray(0));

                #region CalculateDeltaTi
                double Ti = 0;
                //double[] DelteTi = new double[EdgePointNumber];

                for (int count = 0; count < EdgePointNumber; count++)
                {
                    if (Eight_ChainCode[count] == 8 || Eight_ChainCode[count] == 6 || Eight_ChainCode[count] == 4 || Eight_ChainCode[count] == 2)
                    {
                        Ti = Math.Sqrt(2);
                    }
                    else if (Eight_ChainCode[count] == 7 || Eight_ChainCode[count] == 5 || Eight_ChainCode[count] == 3 || Eight_ChainCode[count] == 1)
                    {
                        Ti = 1;
                    }
                    DeltaTi[count] = Ti;
                }
                #endregion

                #region CalculateDeltaXiYi
                //double[] DelteXi = new double[EdgePointNumber];
                //double[] DelteYi = new double[EdgePointNumber];

                for (int count = 0; count < EdgePointNumber; count++)
                {
                    if (Eight_ChainCode[count] == 8 || Eight_ChainCode[count] == 1 || Eight_ChainCode[count] == 2)
                    {
                        DeltaXi[count] = -1;
                    }
                    if (Eight_ChainCode[count] == 7 || Eight_ChainCode[count] == 3)
                    {
                        DeltaXi[count] = 0;
                    }
                    if (Eight_ChainCode[count] == 6 || Eight_ChainCode[count] == 5 || Eight_ChainCode[count] == 4)
                    {
                        DeltaXi[count] = 1;
                    }

                    if (Eight_ChainCode[count] == 8 || Eight_ChainCode[count] == 7 || Eight_ChainCode[count] == 6)
                    {
                        DeltaYi[count] = -1;
                    }
                    if (Eight_ChainCode[count] == 1 || Eight_ChainCode[count] == 5)
                    {
                        DeltaYi[count] = 0;
                    }
                    if (Eight_ChainCode[count] == 2 || Eight_ChainCode[count] == 3 || Eight_ChainCode[count] == 4)
                    {
                        DeltaYi[count] = 1;
                    }

                    //DeltaXi[count] = CalSgn(9 - Eight_ChainCode[count]) * CalSgn(7 - Eight_ChainCode[count]);
                    //DeltaYi[count] = CalSgn(5 - Eight_ChainCode[count]) * CalSgn(Eight_ChainCode[count]);
                }
                #endregion

                #region CalculateTotalTime
                double ti = 0;
                for (int count = 1; count <= EdgePointNumber; count++)
                {
                    ti += DeltaTi[count - 1];
                    TotalTime[count] = ti;
                }
                TotalTime[0] = ti;//
                #endregion
                //ti = ti - 1;
                #region CalculateFourier_A
                for (int SetOrder = 1; SetOrder <= Order; SetOrder++)
                {
                    double Temp = 0;
                    for (int count = 1; count <= EdgePointNumber; count++)
                    {
                        Temp += ((DeltaXi[count - 1] / DeltaTi[count - 1]) * (Math.Cos((2 * SetOrder * Math.PI * TotalTime[count]) / ti) - Math.Cos((2 * SetOrder * Math.PI * TotalTime[count - 1]) / ti)));
                    }
                    Fourier_A[SetOrder] = Temp * (ti / (2 * Math.Pow(SetOrder, 2) * Math.Pow(Math.PI, 2)));
                }
                #endregion

                #region CalculateFourier_B
                for (int SetOrder = 1; SetOrder <= Order; SetOrder++)
                {
                    double Temp = 0;
                    for (int count = 1; count <= EdgePointNumber; count++)
                    {
                        Temp += ((DeltaXi[count - 1] / DeltaTi[count - 1]) * (Math.Sin((2 * SetOrder * Math.PI * TotalTime[count]) / ti) - Math.Sin((2 * SetOrder * Math.PI * TotalTime[count - 1]) / ti)));
                    }
                    Fourier_B[SetOrder] = Temp * (ti / (2 * Math.Pow(SetOrder, 2) * Math.Pow(Math.PI, 2)));
                }
                #endregion

                #region CalculateFourier_C
                for (int SetOrder = 1; SetOrder <= Order; SetOrder++)
                {
                    double Temp = 0;
                    for (int count = 1; count <= EdgePointNumber; count++)
                    {
                        Temp += ((DeltaYi[count - 1] / DeltaTi[count - 1]) * (Math.Cos((2 * SetOrder * Math.PI * TotalTime[count]) / ti) - Math.Cos((2 * SetOrder * Math.PI * TotalTime[count - 1]) / ti)));
                    }
                    Fourier_C[SetOrder] = Temp * (ti / (2 * Math.Pow(SetOrder, 2) * Math.Pow(Math.PI, 2)));
                }
                #endregion

                #region CalculateFourier_D
                for (int SetOrder = 1; SetOrder <= Order; SetOrder++)
                {
                    double Temp = 0;
                    for (int count = 1; count <= EdgePointNumber; count++)
                    {
                        Temp += ((DeltaYi[count - 1] / DeltaTi[count - 1]) * (Math.Sin((2 * SetOrder * Math.PI * TotalTime[count]) / ti) - Math.Sin((2 * SetOrder * Math.PI * TotalTime[count - 1]) / ti)));
                    }
                    Fourier_D[SetOrder] = Temp * (ti / (2 * Math.Pow(SetOrder, 2) * Math.Pow(Math.PI, 2)));
                }
                #endregion

                //DeltaTi = new double[EdgePointNumber];
                //DeltaXi = new double[EdgePointNumber];
                //DeltaYi = new double[EdgePointNumber];
                //TotalTime = new double[EdgePointNumber + 1];
                //Fourier_A = new double[Order + 1];
                //Fourier_B = new double[Order + 1];
                //Fourier_C = new double[Order + 1];
                //Fourier_D = new double[Order + 1];
                Debug.Print("ti: " + ti.ToString());//拜訪輪廓時間(輪廓周長)

                //why OrderN to 10 前面CAL_A CAL_B CAL_C CAL_D不是有跑十次了?
                for (int count = 0; count < EdgePointNumber; count++)
                {
                    for (int OrderN = 1; OrderN <= 10; OrderN++)
                    {
                        XX[count] += (Fourier_A[OrderN] * Math.Cos((2 * Math.PI * TotalTime[count] * OrderN) / ti) + Fourier_B[OrderN] * Math.Sin((2 * Math.PI * TotalTime[count] * OrderN) / ti));
                        YY[count] += (Fourier_C[OrderN] * Math.Cos((2 * Math.PI * TotalTime[count] * OrderN) / ti) + Fourier_D[OrderN] * Math.Sin((2 * Math.PI * TotalTime[count] * OrderN) / ti));
                    }
                }
                //for (int count = 0; count < EdgePointNumber - 1; count++)
                //for(int count =EdgePointNumber-2 ; count >= 0;count--)
                //畫 a

                //for (int count=0; count < EdgePointNumber; count++)
                //{
                //    XX[count] = XX[count];
                //    YY[count] = 600 - 1 - YY[count];
                //}
                for (int count = 0; count < EdgePointNumber - 1; count++)
                {
                    CvInvoke.Line(FD_Image, new Point((int)XX[count] + 500, (int)-YY[count] + 500), new Point((int)XX[count + 1] + 500, (int)-YY[count + 1] + 500), new MCvScalar(255, 0, 0, 0), 1);
                    //CvInvoke.cvLine(FD_image, new Point((int)XX[count] + 200, (int)-YY[count] + 200), new Point((int)XX[count + 1] + 200, (int)-YY[count + 1] + 200), new MCvScalar(255), 1, Emgu.CV.CvEnum.LINE_TYPE.CV_AA, 0);
                }
                CvInvoke.Line(FD_Image, new Point((int)XX[EdgePointNumber - 1] + 500, (int)-YY[EdgePointNumber - 1] + 500), new Point((int)XX[0] + 500, (int)-YY[0] + 500), new MCvScalar(255, 0, 0, 0), 1);
                //G3=G3.Rotate(, new Gray());
                Bitmap bitmap = FD_Image.ToBitmap();
                //bitmap.RotateFlip(RotateFlipType.Rotate180FlipY);
                ///bitmap.RotateFlip(RotateFlipType.RotateNoneFlipX);
                //bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
                bitmap.RotateFlip(RotateFlipType.RotateNoneFlipXY);
                bitmap.RotateFlip(RotateFlipType.RotateNoneFlipX);

                //bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);
                //bitmap.RotateFlip(RotateFlipType.RotateNoneFlipNone);
                //bitmap.RotateFlip(RotateFlipType.RotateNoneFlipXY); 
                Image<Gray, byte> G4 = new Image<Gray, byte>(bitmap);
                //G4=G4.Rotate(90,new Gray());           

                //imageBox2.Image = G4.Bitmap;
                imageBox1.Image = G4;
            }
        }

        private void button22_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                try
                {
                    Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                    ThreadValue.Text = thresholdvalue.Value.ToString();
                    //Image<Gray, byte> CIR_ori = new Image<Gray, byte>(Save_subPic_gray_ori.Bitmap);
                    Image<Gray, byte> CIR = new Image<Gray, byte>(Save_subPic_gray.Bitmap);
                    Image<Gray, byte> CIR_max = new Image<Gray, byte>(Save_subPic_gray.Bitmap);
                    //if (Allow_connect.Checked)
                    //{
                    //    CIR = CIR.Or(CIR_ori);
                    //}
                    // CIR_max = CIR_max.Or(CIR_ori);
                    MCvScalar MCV2 = CvInvoke.Mean(CIR);
                    CvInvoke.Threshold(CIR, CIR_max, thresholdvalue_max.Value, 255, ThresholdType.Binary);
                    Double D = OtsuImg(CIR, (int)MCV2.V0 * 3, 6);
                    CvInvoke.Threshold(CIR, CIR, OtsuImg(CIR, (int)MCV2.V0 * 3, 6), 255, ThresholdType.Binary);

                    ThreadValue.Text = Math.Round(D, 0).ToString();

                    thresholdvalue.Value = (int)D;
                    CIR = CIR.Xor(CIR_max);
                    Image<Bgr, byte> Display = new Image<Bgr, byte>(CIR.Bitmap);
                    Display._And(ori);
                    initialDatagrid();
                    Recover_image = new Image<Bgr, byte>(Display.Bitmap);
                    Image<Bgr, byte> imgxx = new Image<Bgr, byte>(ori.Bitmap);
                    Image<Bgr, byte> imgB = new Image<Bgr, byte>(Display.Bitmap);
                    Image<Bgr, byte> imgB2 = new Image<Bgr, byte>(Display.Bitmap);
                    Image<Bgr, byte> imgC = new Image<Bgr, byte>(ori.Width, ori.Height);
                    Image<Gray, byte> CIR5 = new Image<Gray, byte>(Display.Bitmap);

                    VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存     
                    int Count = 0;
                    CvInvoke.FindContours(CIR5, contours_White, null, RetrType.External, ChainApproxMethod.ChainApproxNone);  //找輪廓語法 
                    for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                    {
                        double AREA = CvInvoke.ContourArea(contours_White[i]);
                        MCvMoments[] mom = new MCvMoments[contours_White.Size]; //形心
                        int[] Cx = new int[contours_White.Size];  //x座標
                        int[] Cy = new int[contours_White.Size];  //y座標 
                        mom[i] = CvInvoke.Moments(contours_White[i]);
                        Cx[i] = (int)mom[i].GravityCenter.X;
                        Cy[i] = (int)mom[i].GravityCenter.Y;
                        if (AREA > (double)Threshold_Area.Value)
                        {

                            RotatedRect rotatedRect = CvInvoke.FitEllipse(contours_White[i]);

                            Point rcenter = new Point(Cx[i], Cy[i]);
                            double A = (int)rotatedRect.Size.Width;
                            double B = (int)rotatedRect.Size.Height;
                            if (Math.Round(B / A, 1) < (double)W_HRate_defect.Value)
                            {
                                Count++;
                                CvInvoke.DrawContours(imgB, contours_White, i, new MCvScalar(0, 255, 255), 1);
                                CvInvoke.DrawContours(imgC, contours_White, i, new MCvScalar(255, 255, 255), -1);

                                if (number_visible.Checked)
                                    CvInvoke.PutText(imgB, Count.ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(255, 255, 255), 1);
                                //CvInvoke.Circle(imgB, new System.Drawing.Point(Cx[i], Cy[i]), 5, new MCvScalar(0, 0, 255), -1);
                                dataGridView1.Rows.Add(Count.ToString(), ((int)AREA).ToString(), Math.Round(B / A, 2).ToString(), Math.Round((int)AREA / (B * A * Math.PI) * 4, 2).ToString());
                                for (int x = 0; x < contours_White[i].Size; x = x + 30)
                                {
                                    if (circle_round.Checked)
                                    {
                                        CvInvoke.Circle(imgB, new Point(contours_White[i][x].X, contours_White[i][x].Y), (int)RoundShape.Value, new MCvScalar(255, 255, 255), -1);
                                        CvInvoke.Ellipse(imgB2, rotatedRect, new MCvScalar(255, 255, 255), 1);
                                    }

                                    if (rect_round.Checked)
                                        // CvInvoke.Rectangle(imgB, new Rectangle(contours_White[i][x].X - (int)RoundShape.Value, contours_White[i][x].Y - (int)RoundShape.Value, 2 * (int)RoundShape.Value, 2 * (int)RoundShape.Value), new MCvScalar(255, 255, 255), -1);

                                        if (triangle_round.Checked)
                                        { }
                                    if (none_round.Checked)
                                    { }
                                    //CvInvoke.(imgB, new Point(contours_White[i][x].X, contours_White[i][x].Y), 10, new MCvScalar(255, 255, 255), -1);


                                    //CvInvoke.Line(imgB, new Point(contours_White[i][x].X, contours_White[i][x].Y), new Point(Cx[i], Cy[i]), new MCvScalar(255, 255, 255), 1);
                                    //imgB.Data[contours_White[i][x].Y, contours_White[i][x].X, 0] = 255;
                                    //imgB.Data[contours_White[i][x].Y, contours_White[i][x].X, 1] = 255;
                                    //imgB.Data[contours_White[i][x].Y, contours_White[i][x].X, 2] = 255;
                                }

                            }
                        }
                    }
                    Image<Gray, byte> imgB_gray = new Image<Gray, byte>(imgB.Bitmap);
                    Image<Bgr, byte> imgB_2 = new Image<Bgr, byte>(1040, 1040);
                    imageBox_otsu.Image = imgB2;
                    if (none_round.Checked)
                    {
                        imgB_gray = imgB_gray.Erode(4);
                        VectorOfVectorOfPoint contours_gray = new VectorOfVectorOfPoint();  //找到的輪廓儲存     
                        CvInvoke.FindContours(imgB_gray, contours_gray, null, RetrType.External, ChainApproxMethod.ChainApproxNone);
                        for (int i = 0; i < contours_gray.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                        {
                            CvInvoke.DrawContours(imgB_2, contours_gray, i, new MCvScalar(0, 255, 255), 1);
                        }
                        Save_Contour_image = imgC;
                        imgB_2 = imgB_2.Or(imgxx);
                        LockImage = new Image<Bgr, byte>(imgB_2.Bitmap);
                        imageBox1.Image = LockImage;
                    }
                    else
                    {
                        Save_Contour_image = imgC;
                        imgB = imgB.Or(imgxx);
                        LockImage = new Image<Bgr, byte>(imgB.Bitmap);
                        imageBox1.Image = LockImage;
                    }

                    //imageBox1.Image = imgC;
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.ToString());
                }


            }
        }

        private void button23_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Grayyyy = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Grayyyy22 = new Image<Gray, byte>(imageBox_otsu.Image.Bitmap);
                CvInvoke.Threshold(Grayyyy, Grayyyy, 200, 255, ThresholdType.Binary);
                CvInvoke.Threshold(Grayyyy22, Grayyyy22, 200, 255, ThresholdType.Binary);
                imageBox1.Image = Grayyyy;
                imageBox_otsu.Image = Grayyyy22;
            }
        }

        private void button24_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> Grayyyy = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                CvInvoke.Threshold(Grayyyy, Grayyyy, 220, 255, ThresholdType.Binary);
                imageBox1.Image = Grayyyy;
            }
        }

        private void button25_Click_1(object sender, EventArgs e)
        {

            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Display = new Image<Bgr, byte>(1040, 1040);
                //ColorPint(ref Connect_img);
                for (int i = 3; i < Connect_img.Width; i++)
                {
                    for (int j = 3; j < Connect_img.Height; j++)
                    {
                        if (Connect_img.Data[j, i, 0] == 0 && Connect_img.Data[j, i, 1] == 0 && Connect_img.Data[j, i, 2] == 0)
                        {

                        }
                        else
                        {
                            if (Connect_img.Data[j, i, 0] == 255 && Connect_img.Data[j, i, 1] == 255 && Connect_img.Data[j, i, 2] == 255)
                            {

                            }
                            else
                            {
                                if (Count_step(i, j, ref Connect_img, 5) < 7)
                                {
                                    Connect_img.Data[Point_front(i, j, Connect_img, 5).Y, Point_front(i, j, Connect_img, 5).X, 0] = 0;
                                    Connect_img.Data[Point_front(i, j, Connect_img, 5).Y, Point_front(i, j, Connect_img, 5).X, 1] = 0;
                                    Connect_img.Data[Point_front(i, j, Connect_img, 5).Y, Point_front(i, j, Connect_img, 5).X, 2] = 255;
                                }

                            }
                        }

                    }
                }
                imageBox1.Image = Connect_img;
            }
        }

        private void button27_Click(object sender, EventArgs e)
        {
            Image<Bgr, Byte> Img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
            Form2 xx = new Form2();
            xx.getimage(Img);
            xx.Show();
        }

        private void button28_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                ColorPint(ref Connect_img);
                imageBox1.Image = Connect_img;
            }
        }

        private void button29_Click_2(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Connect_img._GammaCorrect(0.67);
                imageBox1.Image = Connect_img;
            }
        }

        private void button30_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Connect_img._GammaCorrect(1.5);
                imageBox1.Image = Connect_img;
            }
        }

        private void button31_Click(object sender, EventArgs e)
        {

        }

        private void Combinecc_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void button32_Click_1(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);

                imageBox1.Image = Connect_img.Dilate(1);
            }
        }

        private void button33_Click_1(object sender, EventArgs e)
        {
            Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
            Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
            Image<Bgr, byte> Display = new Image<Bgr, byte>(1040, 1040);
            //ColorPint(ref Connect_img);
            for (int i = 3; i < Connect_img.Width; i++)
            {
                for (int j = 3; j < Connect_img.Height; j++)
                {
                    if (Connect_img.Data[j, i, 0] == 0 && Connect_img.Data[j, i, 1] == 0 && Connect_img.Data[j, i, 2] == 0)
                    {

                    }
                    else
                    {
                        if (Connect_img.Data[j, i, 0] == 255 && Connect_img.Data[j, i, 1] == 255 && Connect_img.Data[j, i, 2] == 255)
                        {

                        }
                        else
                        {
                            if (Count_step(i, j, ref Connect_img, 10) < 13)
                            {
                                imageBox1.Image = Remove_path(i, j, ref Connect_img, 10);
                            }

                        }
                    }

                }
            }

        }

        private void button34_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {

                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                for (int i = 0; i < (int)POINTREMOVETIME.Value; i++)
                    PointRemove(ref Connect_img, (int)POINTREMOVETIME.Value);
                imageBox1.Image = Connect_img;
            }

        }

        private void button35_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {

                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> ori_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img2 = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                ColorPoint_red(ref ori_img);
                for (int i = 0; i < (int)POINTREMOVETIME.Value; i++)
                    PointRemove(ref Connect_img, (int)POINTREMOVETIME.Value);
                ColorPoint_green(ref Connect_img);
                imageBox1.Image = ori_img.Sub(Connect_img);
            }
        }
        private int Oritation(int x, int y, double[,,] M)
        {
            int ret = 8;
            for (int i = 0; i < 8; i++)
            {
                if (M[x, y, i] == 999)
                {

                }
                else
                {
                    ret = i;
                    break;
                }

            }
            return ret;
        }
        private Point RedToGreen(int x, int y, ref Image<Bgr, byte> img, int count)
        {
            Point Retpoint = new Point(0, 0);
            if (count == (int)distance_m.Value)
            {
                img.Data[y, x, 0] = 0;
                img.Data[y, x, 1] = 0;
                img.Data[y, x, 2] = 0;
                Retpoint = new Point(x, y);
            }
            else
            {

                try
                {

                    int Darkpoint = 0;
                    for (int i = -1; i < 2; i++)
                    {
                        for (int j = -1; j < 2; j++)
                        {
                            if (i == 0 && j == 0)
                            { }
                            else
                            {
                                if (img.Data[y + j, x + i, 0] == 255 && img.Data[y + j, x + i, 1] == 255 && img.Data[y + j, x + i, 2] == 255)
                                {
                                    if (img.Data[y, x, 0] == 0 && img.Data[y, x, 1] == 0 && img.Data[y, x, 2] == 255)
                                    {

                                    }
                                    else
                                    {
                                        img.Data[y, x, 0] = 0;
                                        img.Data[y, x, 1] = 0;
                                        img.Data[y, x, 2] = 0;

                                    }
                                    count = count + 1;
                                    Retpoint = RedToGreen(x + i, y + j, ref img, count);

                                }
                                else if (img.Data[y + j, x + i, 0] == 0 && img.Data[y + j, x + i, 1] == 255 && img.Data[y + j, x + i, 2] == 0)
                                {
                                    img.Data[y, x, 0] = 0;
                                    img.Data[y, x, 1] = 0;
                                    img.Data[y, x, 2] = 0;
                                    count = count + 1;
                                    Retpoint = new Point(x + i, y + j);
                                }
                                else if (img.Data[y + j, x + i, 0] == 0 && img.Data[y + j, x + i, 1] == 0 && img.Data[y + j, x + i, 2] == 0)
                                {

                                    Darkpoint = Darkpoint + 1;
                                }


                            }
                        }
                    }
                    if (Darkpoint == 8)
                    {
                        img.Data[y, x, 0] = 0;
                        img.Data[y, x, 1] = 0;
                        img.Data[y, x, 2] = 0;
                        count = count + 1;
                        Retpoint = new Point(x, y);
                    }
                    return Retpoint;
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.ToString());
                    return Retpoint;
                }

                //if(img.Data[y,x,0] == 0 && img.Data[y, x, 1] == 0&& img.Data[y, x, 2] == 255)
            }

            return Retpoint;
        }
        private void button36_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {

                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> ori_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img2 = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(1040, 1040);
                double[,,] M = new double[1040, 1040, 2];
                Point[,] RTG = new Point[1040, 1040];
                for (int a = 0; a < 1040; a++)
                {
                    for (int b = 0; b < 1040; b++)
                    {

                        M[a, b, 0] = 999;
                        M[a, b, 1] = 8;
                    }
                }
                for (int i = 0; i < ori_img.Width; i++)
                {
                    for (int j = 0; j < ori_img.Height; j++)
                    {
                        if (ori_img.Data[j, i, 0] == 0 && ori_img.Data[j, i, 1] == 0 && ori_img.Data[j, i, 2] == 255)
                        {
                            RTG[i, j] = RedToGreen(i, j, ref ori_img, 0);
                            //int step = 0;
                            //int x_step = i;
                            //int y_step = j;
                            //int x_min = i;
                            //int y_min = j;
                            //int x_max = i;
                            //int y_max = j;
                            //Point[] P_pos = new Point[AddOUT(7)];
                            //do
                            //{
                            //    do//up
                            //    {
                            //        step++;
                            //        y_step--;
                            //        P_pos[step] = new Point(x_step, y_step);

                            //    } while (y_step >= y_min);
                            //    y_min = y_step;
                            //    do//right
                            //    {
                            //        step++;
                            //        x_step++;
                            //        P_pos[step] = new Point(x_step, y_step);
                            //    } while (x_step <= x_max);
                            //    x_max = x_step;
                            //    do//down
                            //    {
                            //        step++;
                            //        y_step++;
                            //        P_pos[step] = new Point(x_step, y_step);
                            //    } while (y_step <= y_max);
                            //    y_max = y_step;
                            //    do//left
                            //    {
                            //        step++;
                            //        x_step--;
                            //        P_pos[step] = new Point(x_step, y_step);
                            //    } while (x_step >= x_min);
                            //    x_min = x_step;
                            //} while (step < AddOUT(6));
                            //for (int cc = 1; cc < step; cc++)
                            //{
                            //if (ori_img.Data[RedToGreen(i, j, ref ori_img).Y, RedToGreen(i, j, ref ori_img).X, 0] == 0 && ori_img.Data[RedToGreen(i, j, ref ori_img).Y, RedToGreen(i, j, ref ori_img).X, 1] == 0 && ori_img.Data[RedToGreen(i, j, ref ori_img).Y, RedToGreen(i, j, ref ori_img).X, 2] == 255)
                            //{


                            //CvInvoke.Line(Connect_img, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                            if (i - RTG[i, j].X == 0 && j - RTG[i, j].Y > 0 && Math.Abs(Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2)) >= 2)
                            {
                                M[i, j, 0] = 8;
                                M[i, j, 1] = 0;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 200)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(255, 255, 0), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);
                                }

                            }
                            else if (i - RTG[i, j].X > 0 && j - RTG[i, j].Y < 0 && Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2) < -0.5 && Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2) > -2.0)
                            {
                                M[i, j, 0] = Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 3);
                                M[i, j, 1] = 1;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 300)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(0, 255, 0), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);
                                }

                            }
                            else if (i - RTG[i, j].X > 0 && Math.Abs(Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2)) <= 0.5)
                            {
                                M[i, j, 0] = Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 3);
                                M[i, j, 1] = 2;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 300)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(255, 128, 255), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);
                                }
                            }
                            else if (i - RTG[i, j].X > 0 && j - RTG[i, j].Y > 0 && Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2) > 0.5 && Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2) < 2.0)
                            {
                                M[i, j, 0] = Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 3);
                                M[i, j, 1] = 3;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 300)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(128, 128, 255), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);
                                }

                            }
                            else if (j - RTG[i, j].Y > 0 && Math.Abs(Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2)) >= 2.0)
                            {
                                M[i, j, 0] = Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 3);
                                M[i, j, 1] = 4;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 300)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(128, 255, 255), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);

                                }

                            }
                            else if (j - RTG[i, j].Y < 0 && Math.Abs(Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2)) >= 2.0)
                            {
                                M[i, j, 0] = Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 3);
                                M[i, j, 1] = 0;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 300)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(0, 0, 255), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);


                                }

                            }
                            else if (i - RTG[i, j].X < 0 && j - RTG[i, j].Y > 0 && Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2) < -0.5 && Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2) > -2.0)
                            {
                                M[i, j, 0] = Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 3);
                                M[i, j, 1] = 5;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 300)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(255, 0, 0), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);
                                }
                            }
                            else if (i - RTG[i, j].X < 0 && Math.Abs(Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2)) <= 0.5)
                            {
                                M[i, j, 0] = Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 3);
                                M[i, j, 1] = 6;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 300)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(128, 128, 128), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);
                                }
                            }
                            else if (i - RTG[i, j].X < 0 && j - RTG[i, j].Y < 0 && Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2) > 0.5 && Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2) < 2.0)
                            {
                                M[i, j, 0] = Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 3);
                                M[i, j, 1] = 7;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 300)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(255, 128, 128), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);
                                }
                            }
                            else if (i - RTG[i, j].X == 0 && j - RTG[i, j].Y < 0 && Math.Abs(Math.Round(((double)(j - RTG[i, j].Y) / (double)(i - RTG[i, j].X)), 2)) >= 2)
                            {
                                M[i, j, 0] = 8;
                                M[i, j, 1] = 4;
                                if (Math.Sqrt(Math.Pow(i - RTG[i, j].X, 2) + Math.Pow(j - RTG[i, j].Y, 2)) > 300)
                                {

                                }
                                else
                                {
                                    CvInvoke.Line(Connect_img, new Point(i, j), new Point(RTG[i, j].X, RTG[i, j].Y), new MCvScalar(255, 0, 255), 1);
                                    CvInvoke.Line(Connect_img, new Point(RTG[i, j].X, RTG[i, j].Y), new Point(RTG[i, j].X + (RTG[i, j].X - i), RTG[i, j].Y + (RTG[i, j].Y - j)), new MCvScalar(255, 255, 0), 1);
                                }
                            }

                            //CvInvoke.PutText(Connect_img, M[i, j].ToString(), new System.Drawing.Point(i, j), Emgu.CV.CvEnum.FontFace.HersheyComplex,0.5, new MCvScalar(255, 255, 0), 1);
                            //}
                            //}

                        }
                    }

                }
                //for (int i = 20; i < ori_img.Width - 20; i++)
                //{
                //    for (int j = 20; j < ori_img.Height - 20; j++)
                //    {
                //        if (ori_img.Data[j, i, 0] == 0 && ori_img.Data[j, i, 1] == 0 && ori_img.Data[j, i, 2] == 255)
                //        {

                //            int step = 0;
                //            int x_step = i;
                //            int y_step = j;
                //            int x_min = i;
                //            int y_min = j;
                //            int x_max = i;
                //            int y_max = j;
                //            Point[] P_pos = new Point[AddOUT(21)];
                //            do
                //            {
                //                do//up
                //                {
                //                    step++;
                //                    y_step--;
                //                    P_pos[step] = new Point(x_step, y_step);

                //                } while (y_step >= y_min);
                //                y_min = y_step;
                //                do//right
                //                {
                //                    step++;
                //                    x_step++;
                //                    P_pos[step] = new Point(x_step, y_step);
                //                } while (x_step <= x_max);
                //                x_max = x_step;
                //                do//down
                //                {
                //                    step++;
                //                    y_step++;
                //                    P_pos[step] = new Point(x_step, y_step);
                //                } while (y_step <= y_max);
                //                y_max = y_step;
                //                do//left
                //                {
                //                    step++;
                //                    x_step--;
                //                    P_pos[step] = new Point(x_step, y_step);
                //                } while (x_step >= x_min);
                //                x_min = x_step;
                //            } while (step < AddOUT(20));
                //            for (int cc = 1; cc < step; cc++)
                //            {
                //                //ori_img.Data[P_pos[cc].Y, P_pos[cc].X, 0] = 255;
                //                if (ori_img.Data[P_pos[cc].Y, P_pos[cc].X, 0] == 0 && ori_img.Data[P_pos[cc].Y, P_pos[cc].X, 1] == 0 && ori_img.Data[P_pos[cc].Y, P_pos[cc].X, 2] == 255)
                //                {
                //                    {

                //                        if (M[P_pos[cc].X, P_pos[cc].Y, 1] == 8)
                //                        { }
                //                        else
                //                        {
                //                            if (M[i, j, 1] == 1 && i - P_pos[cc].X < 0 && j - P_pos[cc].Y > 0 && M[P_pos[cc].X, P_pos[cc].Y, 1] == 5)
                //                            {
                //                                CvInvoke.Line(ori_img, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                //                            }
                //                            else if (M[i, j, 1] == 0 && j - P_pos[cc].Y > 0 && M[P_pos[cc].X, P_pos[cc].Y, 1] == 4)
                //                            {
                //                                CvInvoke.Line(ori_img, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                //                            }
                //                            else if (M[i, j, 1] == 2 && i - P_pos[cc].X > 0 && M[P_pos[cc].X, P_pos[cc].Y, 1] == 6)
                //                            {
                //                                CvInvoke.Line(ori_img, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                //                            }
                //                            else if (M[i, j, 1] == 3 && j - P_pos[cc].Y < 0 && i - P_pos[cc].X < 0 && M[P_pos[cc].X, P_pos[cc].Y, 1] == 7)
                //                            {
                //                                CvInvoke.Line(ori_img, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                //                            }
                //                            else if (M[i, j, 1] == 4 && j - P_pos[cc].Y < 0 && M[P_pos[cc].X, P_pos[cc].Y, 1] == 0)
                //                            {
                //                                CvInvoke.Line(ori_img, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                //                            }
                //                            else if (M[i, j, 1] == 5 && i - P_pos[cc].X > 0 && j - P_pos[cc].Y < 0 && M[P_pos[cc].X, P_pos[cc].Y, 1] == 1)
                //                            {
                //                                CvInvoke.Line(ori_img, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                //                            }
                //                            else if (M[i, j, 1] == 6 && i - P_pos[cc].X > 0 && M[P_pos[cc].X, P_pos[cc].Y, 1] == 2)
                //                            {
                //                                CvInvoke.Line(ori_img, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                //                            }
                //                            else if (M[i, j, 1] == 7 && i - P_pos[cc].X > 0 && j - P_pos[cc].Y > 0 && M[P_pos[cc].X, P_pos[cc].Y, 1] == 3)
                //                            {
                //                                CvInvoke.Line(ori_img, new Point(i, j), new Point(P_pos[cc].X, P_pos[cc].Y), new MCvScalar(255, 255, 255), 1);
                //                            }
                //                        }


                //                        //CvInvoke.PutText(Connect_img, M[i, j].ToString(), new System.Drawing.Point(i, j), Emgu.CV.CvEnum.FontFace.HersheyComplex, 0.5, new MCvScalar(255, 255, 0), 1);
                //                    }
                //                }

                //            }
                //        }
                //    }
                //imageBox1.Image = Connect_img;

                imageBox1.Image = Connect_img;
            }

        }

        private void button38_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {

                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> ori_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img2 = new Image<Bgr, byte>(1040, 1040);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                for (int i = 0; i < Connect_img.Width; i++)
                {
                    for (int j = 0; j < Connect_img.Height; j++)
                    {
                        if (Math.Sqrt(Math.Pow(i - Ori_x, 2) + Math.Pow(j - Ori_y, 2)) > (int)Circle_Filter.Value && Math.Sqrt(Math.Pow(i - Ori_x, 2) + Math.Pow(j - Ori_y, 2)) < (int)Circle_Filter.Value + 3)
                        {
                            if (Connect_img.Data[j, i, 0] == 255 && Connect_img.Data[j, i, 1] == 255 && Connect_img.Data[j, i, 2] == 255)
                            {
                                Connect_img.Data[j, i, 0] = 0;
                                Connect_img.Data[j, i, 1] = 0;
                                Connect_img.Data[j, i, 2] = 255;
                            }

                        }
                        if (Math.Sqrt(Math.Pow(i - Ori_x, 2) + Math.Pow(j - Ori_y, 2)) < (int)Circle_Filter.Value)
                        {
                            Connect_img.Data[j, i, 0] = 0;
                            Connect_img.Data[j, i, 1] = 0;
                            Connect_img.Data[j, i, 2] = 0;
                        }
                    }
                }
                imageBox1.Image = Connect_img;
            }
        }

        private void Circle_Filter_out_Scroll(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                lbl_circlr_filter_out.Text = Circle_Filter_out.Value.ToString();
                button8_Click(sender, e);
                Image<Bgr, byte> Display222 = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                CvInvoke.Circle(Display222, new Point(Ori_x, Ori_y), 3, new MCvScalar(0, 255, 255), -1);
                CvInvoke.Circle(Display222, new Point(Ori_x, Ori_y), Circle_Filter_out.Value, new MCvScalar(0, 255, 255));
                imageBox1.Image = Display222;
            }
        }

        private void button37_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {

                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> ori_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img2 = new Image<Bgr, byte>(1040, 1040);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                for (int i = 0; i < Connect_img.Width; i++)
                {
                    for (int j = 0; j < Connect_img.Height; j++)
                    {
                        if (Math.Sqrt(Math.Pow(i - Ori_x, 2) + Math.Pow(j - Ori_y, 2)) > (int)Circle_Filter_out.Value && Math.Sqrt(Math.Pow(i - Ori_x, 2) + Math.Pow(j - Ori_y, 2)) < (int)Circle_Filter_out.Value + 3)
                        {
                            if (Connect_img.Data[j, i, 0] == 255 && Connect_img.Data[j, i, 1] == 255 && Connect_img.Data[j, i, 2] == 255)
                            {
                                Connect_img.Data[j, i, 0] = 0;
                                Connect_img.Data[j, i, 1] = 255;
                                Connect_img.Data[j, i, 2] = 0;
                            }

                        }
                        if (Math.Sqrt(Math.Pow(i - Ori_x, 2) + Math.Pow(j - Ori_y, 2)) > (int)Circle_Filter_out.Value + 2)
                        {
                            Connect_img.Data[j, i, 0] = 0;
                            Connect_img.Data[j, i, 1] = 0;
                            Connect_img.Data[j, i, 2] = 0;
                        }
                    }
                    imageBox1.Image = Connect_img;
                }
            }
        }

        private void button40_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {

                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> ori_img = new Image<Bgr, byte>("C:/Users/K501/Pictures/2.png");
                Image<Bgr, byte> Connect_img2 = new Image<Bgr, byte>("C:/Users/K501/Pictures/3.png");
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                for (int i = 0; i < 780 - 1; i++)
                {
                    for (int j = 0; j < 780; j++)
                    {
                        if (Connect_img2.Data[j, i, 2] > Connect_img.Data[j, i, 2] && Connect_img2.Data[j, i, 1] > Connect_img.Data[j, i, 1])
                        {
                            Connect_img.Data[j, i, 0] = Connect_img2.Data[j, i, 0];
                            Connect_img.Data[j, i, 1] = Connect_img2.Data[j, i, 1];
                            Connect_img.Data[j, i, 2] = Connect_img2.Data[j, i, 2];
                        }
                        if (ori_img.Data[j, i, 2] > Connect_img.Data[j, i, 2] && ori_img.Data[j, i, 1] > Connect_img.Data[j, i, 1])
                        {
                            Connect_img.Data[j, i, 0] = ori_img.Data[j, i, 0];
                            Connect_img.Data[j, i, 1] = ori_img.Data[j, i, 1];
                            Connect_img.Data[j, i, 2] = ori_img.Data[j, i, 2];
                        }
                    }
                }
                imageBox1.Image = Connect_img;

            }
        }

        private void button41_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Recover_image = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                Image<Bgr, byte> Connect_img = new Image<Bgr, byte>(imageBox1.Image.Bitmap);

                imageBox1.Image = Connect_img.Erode(1);
            }
        }

        private void button42_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                double[] A_area = new double[3];
                double[] B_area = new double[3];
                double[] C_area = new double[4];
                int count = 0;
                int count2 = 0;
                int count3 = 0;
                imageBox_otsu.Image = new Image<Bgr, byte>("C:/Users/K501/Downloads/111.jpg");
                Image<Gray, byte> CIR22 = new Image<Gray, byte>(imageBox_otsu.Image.Bitmap);
                CvInvoke.Resize(CIR22, CIR22, new Size(784, 788));
                Image<Gray, byte> CIR = new Image<Gray, byte>(imageBox1.Image.Bitmap);
                Image<Gray, byte> imgA = new Image<Gray, byte>(ori[1].ToBitmap());
                Image<Gray, byte> imgB = new Image<Gray, byte>(CIR.ToBitmap());
                Image<Bgr, byte> img_Displayggg = new Image<Bgr, byte>(imgB.ToBitmap().Width, imgB.ToBitmap().Height);
                Image<Bgr, byte> imgdisplay = new Image<Bgr, byte>(784, 788);
                Image<Bgr, byte> CIR2 = new Image<Bgr, byte>(784, 788);
                Image<Gray, byte> CIR255 = new Image<Gray, byte>(784, 788);
                Image<Gray, byte> CIR255_dis = new Image<Gray, byte>(784, 788);
                VectorOfVectorOfPoint contours_White = new VectorOfVectorOfPoint();  //找到的輪廓儲存
                VectorOfRect hierarchy = new VectorOfRect();
                CvInvoke.FindContours(imgB, contours_White, hierarchy, RetrType.External, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 
                CvInvoke.Threshold(CIR22, CIR2, 120, 255, ThresholdType.Binary);
                VectorOfVectorOfPoint contours_White2 = new VectorOfVectorOfPoint();  //找到的輪廓儲存
                VectorOfRect hierarchy2 = new VectorOfRect();
                CvInvoke.FindContours(CIR2, contours_White2, hierarchy2, RetrType.External, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 

                for (int i = 0; i < contours_White.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {

                    //imgB.SetZero();
                    // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                    double A = CvInvoke.ContourArea(contours_White[i]);
                    // Debug.Print(A.ToString());
                    
                    if (A > 1200 && A < 60000)
                    {

                        CvInvoke.DrawContours(img_Displayggg, contours_White, i, new MCvScalar(255, 255, 255), -1);
                        //CvInvoke.PutText(img_Displayggg, (count + 1).ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(0, 0, 255), 1);
                        
                        A_area[count] = A;
                        count = count + 1;

                    }
                }
                for (int i = 0; i < contours_White2.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {

                    //imgB.SetZero();
                    // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                    double A = CvInvoke.ContourArea(contours_White2[i]);
                    // Debug.Print(A.ToString());
                    MCvMoments[] mom = new MCvMoments[contours_White2.Size]; //形心
                    int[] Cx = new int[contours_White2.Size];  //x座標
                    int[] Cy = new int[contours_White2.Size];  //y座標                
                    mom[i] = CvInvoke.Moments(contours_White2[i]);
                    Cx[i] = (int)mom[i].GravityCenter.X;
                    Cy[i] = (int)mom[i].GravityCenter.Y;



                    if (A > 1250 && A < 60000)
                    {
                        CvInvoke.DrawContours(imgdisplay, contours_White2, i, new MCvScalar(255, 255, 255), -1);
                        CvInvoke.PutText(imgdisplay, (count3 + 1).ToString(), new System.Drawing.Point(Cx[i], Cy[i]), Emgu.CV.CvEnum.FontFace.HersheyComplex, 2, new MCvScalar(0, 0, 255), 1);
                        C_area[count3] = A;
                        count3 = count3 + 1;
                    }
                }
                for (int i = 0; i < 784; i++)
                {
                    for (int j = 0; j < 788; j++)
                    {
                        if (img_Displayggg.Data[j, i, 0] == 255 && imgdisplay.Data[j, i, 0] == 255)
                            CIR255.Data[j, i, 0] = 255;
                    }
                }
                VectorOfVectorOfPoint contours_White3 = new VectorOfVectorOfPoint();  //找到的輪廓儲存
                VectorOfRect hierarchy3 = new VectorOfRect();
                CvInvoke.FindContours(CIR255, contours_White3, hierarchy3, RetrType.External, ChainApproxMethod.ChainApproxSimple);  //找輪廓語法 
                for (int i = 0; i < contours_White3.Size; i++)  //一個輪廓表示一個物體 //for對所有輪廓
                {

                    //imgB.SetZero();
                    // CvInvoke.DrawContours(img_White, contours_B, i, new MCvScalar(255, 255, 255), -1);  //把找到的物體畫出來        

                    double A = CvInvoke.ContourArea(contours_White3[i]);
                    // Debug.Print(A.ToString());
                    if (A > 25 && A < 60000)
                    {
                        CvInvoke.DrawContours(CIR255_dis, contours_White3, i, new MCvScalar(255, 255, 255), -1);
                        B_area[count2] = A;
                        count2 = count2 + 1;
                    }


                }
                for (int i = 0; i < 3; i++)
                    MessageBox.Show( A_area[i].ToString() +"-"+ C_area[i].ToString() + "-" + B_area[i].ToString());
                imageBox1.Image = imgdisplay;

            }
        }

        private void button43_Click(object sender, EventArgs e)
        {
            if (imageBox1.Image == null)
            {
                MessageBox.Show("no image");
            }
            else
            {
                Image<Bgr, byte> CIR22 = new Image<Bgr, byte>(imageBox1.Image.Bitmap);
                CvInvoke.Resize(CIR22, CIR22, new Size(784, 788));
                imageBox1.Image = CIR22;
            }

        }
    }
}




